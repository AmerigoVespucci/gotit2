// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GenDef.proto

#ifndef PROTOBUF_GenDef_2eproto__INCLUDED
#define PROTOBUF_GenDef_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_GenDef_2eproto();
void protobuf_AssignDesc_GenDef_2eproto();
void protobuf_ShutdownFile_GenDef_2eproto();

class CaffeGenDef;
class CaffeGenDef_DataAccess;
class CaffeGenDef_DataFilterOneSide;
class CaffeGenDef_DataFilter;
class CaffeGenDef_DataTranslate;
class CaffeGenDef_NetValue;

enum CaffeGenDef_AccessType {
  CaffeGenDef_AccessType_ACCESS_TYPE_DEP = 1,
  CaffeGenDef_AccessType_ACCESS_TYPE_WORD = 2
};
bool CaffeGenDef_AccessType_IsValid(int value);
const CaffeGenDef_AccessType CaffeGenDef_AccessType_AccessType_MIN = CaffeGenDef_AccessType_ACCESS_TYPE_DEP;
const CaffeGenDef_AccessType CaffeGenDef_AccessType_AccessType_MAX = CaffeGenDef_AccessType_ACCESS_TYPE_WORD;
const int CaffeGenDef_AccessType_AccessType_ARRAYSIZE = CaffeGenDef_AccessType_AccessType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CaffeGenDef_AccessType_descriptor();
inline const ::std::string& CaffeGenDef_AccessType_Name(CaffeGenDef_AccessType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CaffeGenDef_AccessType_descriptor(), value);
}
inline bool CaffeGenDef_AccessType_Parse(
    const ::std::string& name, CaffeGenDef_AccessType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CaffeGenDef_AccessType>(
    CaffeGenDef_AccessType_descriptor(), name, value);
}
enum CaffeGenDef_MatchType {
  CaffeGenDef_MatchType_mtDEP_RDID = 1,
  CaffeGenDef_MatchType_mtDEP_GOV_RWID = 2,
  CaffeGenDef_MatchType_mtDEP_DEP_RWID = 3,
  CaffeGenDef_MatchType_mtWORD_RWID = 4,
  CaffeGenDef_MatchType_mtWORD_CORE = 5,
  CaffeGenDef_MatchType_mtWORD_WORD = 6,
  CaffeGenDef_MatchType_mtWORD_POS = 7
};
bool CaffeGenDef_MatchType_IsValid(int value);
const CaffeGenDef_MatchType CaffeGenDef_MatchType_MatchType_MIN = CaffeGenDef_MatchType_mtDEP_RDID;
const CaffeGenDef_MatchType CaffeGenDef_MatchType_MatchType_MAX = CaffeGenDef_MatchType_mtWORD_POS;
const int CaffeGenDef_MatchType_MatchType_ARRAYSIZE = CaffeGenDef_MatchType_MatchType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CaffeGenDef_MatchType_descriptor();
inline const ::std::string& CaffeGenDef_MatchType_Name(CaffeGenDef_MatchType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CaffeGenDef_MatchType_descriptor(), value);
}
inline bool CaffeGenDef_MatchType_Parse(
    const ::std::string& name, CaffeGenDef_MatchType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CaffeGenDef_MatchType>(
    CaffeGenDef_MatchType_descriptor(), name, value);
}
enum CaffeGenDef_FilterMatchType {
  CaffeGenDef_FilterMatchType_fmtEqual = 1,
  CaffeGenDef_FilterMatchType_fmtClose = 2
};
bool CaffeGenDef_FilterMatchType_IsValid(int value);
const CaffeGenDef_FilterMatchType CaffeGenDef_FilterMatchType_FilterMatchType_MIN = CaffeGenDef_FilterMatchType_fmtEqual;
const CaffeGenDef_FilterMatchType CaffeGenDef_FilterMatchType_FilterMatchType_MAX = CaffeGenDef_FilterMatchType_fmtClose;
const int CaffeGenDef_FilterMatchType_FilterMatchType_ARRAYSIZE = CaffeGenDef_FilterMatchType_FilterMatchType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CaffeGenDef_FilterMatchType_descriptor();
inline const ::std::string& CaffeGenDef_FilterMatchType_Name(CaffeGenDef_FilterMatchType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CaffeGenDef_FilterMatchType_descriptor(), value);
}
inline bool CaffeGenDef_FilterMatchType_Parse(
    const ::std::string& name, CaffeGenDef_FilterMatchType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CaffeGenDef_FilterMatchType>(
    CaffeGenDef_FilterMatchType_descriptor(), name, value);
}
enum CaffeGenDef_WordDataType {
  CaffeGenDef_WordDataType_wdtWORD = 1,
  CaffeGenDef_WordDataType_wdtPOS = 2,
  CaffeGenDef_WordDataType_wdtCORE = 3
};
bool CaffeGenDef_WordDataType_IsValid(int value);
const CaffeGenDef_WordDataType CaffeGenDef_WordDataType_WordDataType_MIN = CaffeGenDef_WordDataType_wdtWORD;
const CaffeGenDef_WordDataType CaffeGenDef_WordDataType_WordDataType_MAX = CaffeGenDef_WordDataType_wdtCORE;
const int CaffeGenDef_WordDataType_WordDataType_ARRAYSIZE = CaffeGenDef_WordDataType_WordDataType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CaffeGenDef_WordDataType_descriptor();
inline const ::std::string& CaffeGenDef_WordDataType_Name(CaffeGenDef_WordDataType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CaffeGenDef_WordDataType_descriptor(), value);
}
inline bool CaffeGenDef_WordDataType_Parse(
    const ::std::string& name, CaffeGenDef_WordDataType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CaffeGenDef_WordDataType>(
    CaffeGenDef_WordDataType_descriptor(), name, value);
}
enum CaffeGenDef_DataTranslateType {
  CaffeGenDef_DataTranslateType_dttRWID_TO_WORD = 1,
  CaffeGenDef_DataTranslateType_dttRWID_TO_COREF = 2,
  CaffeGenDef_DataTranslateType_dttRWID_TO_RDID = 3,
  CaffeGenDef_DataTranslateType_dttRDID_TO_DEP_NAME = 4,
  CaffeGenDef_DataTranslateType_dttRDID_TO_GOV_RWID = 5,
  CaffeGenDef_DataTranslateType_dttRDID_TO_DEP_RWID = 6
};
bool CaffeGenDef_DataTranslateType_IsValid(int value);
const CaffeGenDef_DataTranslateType CaffeGenDef_DataTranslateType_DataTranslateType_MIN = CaffeGenDef_DataTranslateType_dttRWID_TO_WORD;
const CaffeGenDef_DataTranslateType CaffeGenDef_DataTranslateType_DataTranslateType_MAX = CaffeGenDef_DataTranslateType_dttRDID_TO_DEP_RWID;
const int CaffeGenDef_DataTranslateType_DataTranslateType_ARRAYSIZE = CaffeGenDef_DataTranslateType_DataTranslateType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CaffeGenDef_DataTranslateType_descriptor();
inline const ::std::string& CaffeGenDef_DataTranslateType_Name(CaffeGenDef_DataTranslateType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CaffeGenDef_DataTranslateType_descriptor(), value);
}
inline bool CaffeGenDef_DataTranslateType_Parse(
    const ::std::string& name, CaffeGenDef_DataTranslateType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CaffeGenDef_DataTranslateType>(
    CaffeGenDef_DataTranslateType_descriptor(), name, value);
}
enum CaffeGenDef_VarExtractType {
  CaffeGenDef_VarExtractType_vetPOS = 1,
  CaffeGenDef_VarExtractType_vetWordCore = 2,
  CaffeGenDef_VarExtractType_vetWord = 3,
  CaffeGenDef_VarExtractType_vetDepName = 4,
  CaffeGenDef_VarExtractType_vetDummy = 5,
  CaffeGenDef_VarExtractType_vetNumDepGovs = 6
};
bool CaffeGenDef_VarExtractType_IsValid(int value);
const CaffeGenDef_VarExtractType CaffeGenDef_VarExtractType_VarExtractType_MIN = CaffeGenDef_VarExtractType_vetPOS;
const CaffeGenDef_VarExtractType CaffeGenDef_VarExtractType_VarExtractType_MAX = CaffeGenDef_VarExtractType_vetNumDepGovs;
const int CaffeGenDef_VarExtractType_VarExtractType_ARRAYSIZE = CaffeGenDef_VarExtractType_VarExtractType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CaffeGenDef_VarExtractType_descriptor();
inline const ::std::string& CaffeGenDef_VarExtractType_Name(CaffeGenDef_VarExtractType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CaffeGenDef_VarExtractType_descriptor(), value);
}
inline bool CaffeGenDef_VarExtractType_Parse(
    const ::std::string& name, CaffeGenDef_VarExtractType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CaffeGenDef_VarExtractType>(
    CaffeGenDef_VarExtractType_descriptor(), name, value);
}
enum CaffeGenDef_NetEndType {
  CaffeGenDef_NetEndType_END_VALID = 1,
  CaffeGenDef_NetEndType_END_ONE_HOT = 2,
  CaffeGenDef_NetEndType_END_MULTI_HOT = 3
};
bool CaffeGenDef_NetEndType_IsValid(int value);
const CaffeGenDef_NetEndType CaffeGenDef_NetEndType_NetEndType_MIN = CaffeGenDef_NetEndType_END_VALID;
const CaffeGenDef_NetEndType CaffeGenDef_NetEndType_NetEndType_MAX = CaffeGenDef_NetEndType_END_MULTI_HOT;
const int CaffeGenDef_NetEndType_NetEndType_ARRAYSIZE = CaffeGenDef_NetEndType_NetEndType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CaffeGenDef_NetEndType_descriptor();
inline const ::std::string& CaffeGenDef_NetEndType_Name(CaffeGenDef_NetEndType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CaffeGenDef_NetEndType_descriptor(), value);
}
inline bool CaffeGenDef_NetEndType_Parse(
    const ::std::string& name, CaffeGenDef_NetEndType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CaffeGenDef_NetEndType>(
    CaffeGenDef_NetEndType_descriptor(), name, value);
}
// ===================================================================

class CaffeGenDef_DataAccess : public ::google::protobuf::Message {
 public:
  CaffeGenDef_DataAccess();
  virtual ~CaffeGenDef_DataAccess();

  CaffeGenDef_DataAccess(const CaffeGenDef_DataAccess& from);

  inline CaffeGenDef_DataAccess& operator=(const CaffeGenDef_DataAccess& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CaffeGenDef_DataAccess& default_instance();

  void Swap(CaffeGenDef_DataAccess* other);

  // implements Message ----------------------------------------------

  CaffeGenDef_DataAccess* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CaffeGenDef_DataAccess& from);
  void MergeFrom(const CaffeGenDef_DataAccess& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string var_name = 1;
  inline bool has_var_name() const;
  inline void clear_var_name();
  static const int kVarNameFieldNumber = 1;
  inline const ::std::string& var_name() const;
  inline void set_var_name(const ::std::string& value);
  inline void set_var_name(const char* value);
  inline void set_var_name(const char* value, size_t size);
  inline ::std::string* mutable_var_name();
  inline ::std::string* release_var_name();
  inline void set_allocated_var_name(::std::string* var_name);

  // required .CaffeGenDef.AccessType access_type = 2;
  inline bool has_access_type() const;
  inline void clear_access_type();
  static const int kAccessTypeFieldNumber = 2;
  inline ::CaffeGenDef_AccessType access_type() const;
  inline void set_access_type(::CaffeGenDef_AccessType value);

  // optional string dep_type_to_match = 3;
  inline bool has_dep_type_to_match() const;
  inline void clear_dep_type_to_match();
  static const int kDepTypeToMatchFieldNumber = 3;
  inline const ::std::string& dep_type_to_match() const;
  inline void set_dep_type_to_match(const ::std::string& value);
  inline void set_dep_type_to_match(const char* value);
  inline void set_dep_type_to_match(const char* value, size_t size);
  inline ::std::string* mutable_dep_type_to_match();
  inline ::std::string* release_dep_type_to_match();
  inline void set_allocated_dep_type_to_match(::std::string* dep_type_to_match);

  // optional string POS_to_match = 4;
  inline bool has_pos_to_match() const;
  inline void clear_pos_to_match();
  static const int kPOSToMatchFieldNumber = 4;
  inline const ::std::string& pos_to_match() const;
  inline void set_pos_to_match(const ::std::string& value);
  inline void set_pos_to_match(const char* value);
  inline void set_pos_to_match(const char* value, size_t size);
  inline ::std::string* mutable_pos_to_match();
  inline ::std::string* release_pos_to_match();
  inline void set_allocated_pos_to_match(::std::string* pos_to_match);

  // optional int32 var_idx = 5;
  inline bool has_var_idx() const;
  inline void clear_var_idx();
  static const int kVarIdxFieldNumber = 5;
  inline ::google::protobuf::int32 var_idx() const;
  inline void set_var_idx(::google::protobuf::int32 value);

  // optional int32 max_srec_beyond = 11;
  inline bool has_max_srec_beyond() const;
  inline void clear_max_srec_beyond();
  static const int kMaxSrecBeyondFieldNumber = 11;
  inline ::google::protobuf::int32 max_srec_beyond() const;
  inline void set_max_srec_beyond(::google::protobuf::int32 value);

  // optional int32 min_srec_beyond = 12;
  inline bool has_min_srec_beyond() const;
  inline void clear_min_srec_beyond();
  static const int kMinSrecBeyondFieldNumber = 12;
  inline ::google::protobuf::int32 min_srec_beyond() const;
  inline void set_min_srec_beyond(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CaffeGenDef.DataAccess)
 private:
  inline void set_has_var_name();
  inline void clear_has_var_name();
  inline void set_has_access_type();
  inline void clear_has_access_type();
  inline void set_has_dep_type_to_match();
  inline void clear_has_dep_type_to_match();
  inline void set_has_pos_to_match();
  inline void clear_has_pos_to_match();
  inline void set_has_var_idx();
  inline void clear_has_var_idx();
  inline void set_has_max_srec_beyond();
  inline void clear_has_max_srec_beyond();
  inline void set_has_min_srec_beyond();
  inline void clear_has_min_srec_beyond();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* var_name_;
  ::std::string* dep_type_to_match_;
  int access_type_;
  ::google::protobuf::int32 var_idx_;
  ::std::string* pos_to_match_;
  ::google::protobuf::int32 max_srec_beyond_;
  ::google::protobuf::int32 min_srec_beyond_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_GenDef_2eproto();
  friend void protobuf_AssignDesc_GenDef_2eproto();
  friend void protobuf_ShutdownFile_GenDef_2eproto();

  void InitAsDefaultInstance();
  static CaffeGenDef_DataAccess* default_instance_;
};
// -------------------------------------------------------------------

class CaffeGenDef_DataFilterOneSide : public ::google::protobuf::Message {
 public:
  CaffeGenDef_DataFilterOneSide();
  virtual ~CaffeGenDef_DataFilterOneSide();

  CaffeGenDef_DataFilterOneSide(const CaffeGenDef_DataFilterOneSide& from);

  inline CaffeGenDef_DataFilterOneSide& operator=(const CaffeGenDef_DataFilterOneSide& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CaffeGenDef_DataFilterOneSide& default_instance();

  void Swap(CaffeGenDef_DataFilterOneSide* other);

  // implements Message ----------------------------------------------

  CaffeGenDef_DataFilterOneSide* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CaffeGenDef_DataFilterOneSide& from);
  void MergeFrom(const CaffeGenDef_DataFilterOneSide& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string var_name_src = 1;
  inline bool has_var_name_src() const;
  inline void clear_var_name_src();
  static const int kVarNameSrcFieldNumber = 1;
  inline const ::std::string& var_name_src() const;
  inline void set_var_name_src(const ::std::string& value);
  inline void set_var_name_src(const char* value);
  inline void set_var_name_src(const char* value, size_t size);
  inline ::std::string* mutable_var_name_src();
  inline ::std::string* release_var_name_src();
  inline void set_allocated_var_name_src(::std::string* var_name_src);

  // required .CaffeGenDef.MatchType mt = 2;
  inline bool has_mt() const;
  inline void clear_mt();
  static const int kMtFieldNumber = 2;
  inline ::CaffeGenDef_MatchType mt() const;
  inline void set_mt(::CaffeGenDef_MatchType value);

  // optional int32 var_src_idx = 3;
  inline bool has_var_src_idx() const;
  inline void clear_var_src_idx();
  static const int kVarSrcIdxFieldNumber = 3;
  inline ::google::protobuf::int32 var_src_idx() const;
  inline void set_var_src_idx(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CaffeGenDef.DataFilterOneSide)
 private:
  inline void set_has_var_name_src();
  inline void clear_has_var_name_src();
  inline void set_has_mt();
  inline void clear_has_mt();
  inline void set_has_var_src_idx();
  inline void clear_has_var_src_idx();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* var_name_src_;
  int mt_;
  ::google::protobuf::int32 var_src_idx_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_GenDef_2eproto();
  friend void protobuf_AssignDesc_GenDef_2eproto();
  friend void protobuf_ShutdownFile_GenDef_2eproto();

  void InitAsDefaultInstance();
  static CaffeGenDef_DataFilterOneSide* default_instance_;
};
// -------------------------------------------------------------------

class CaffeGenDef_DataFilter : public ::google::protobuf::Message {
 public:
  CaffeGenDef_DataFilter();
  virtual ~CaffeGenDef_DataFilter();

  CaffeGenDef_DataFilter(const CaffeGenDef_DataFilter& from);

  inline CaffeGenDef_DataFilter& operator=(const CaffeGenDef_DataFilter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CaffeGenDef_DataFilter& default_instance();

  void Swap(CaffeGenDef_DataFilter* other);

  // implements Message ----------------------------------------------

  CaffeGenDef_DataFilter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CaffeGenDef_DataFilter& from);
  void MergeFrom(const CaffeGenDef_DataFilter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CaffeGenDef.FilterMatchType fmt = 1;
  inline bool has_fmt() const;
  inline void clear_fmt();
  static const int kFmtFieldNumber = 1;
  inline ::CaffeGenDef_FilterMatchType fmt() const;
  inline void set_fmt(::CaffeGenDef_FilterMatchType value);

  // required .CaffeGenDef.DataFilterOneSide left_side = 2;
  inline bool has_left_side() const;
  inline void clear_left_side();
  static const int kLeftSideFieldNumber = 2;
  inline const ::CaffeGenDef_DataFilterOneSide& left_side() const;
  inline ::CaffeGenDef_DataFilterOneSide* mutable_left_side();
  inline ::CaffeGenDef_DataFilterOneSide* release_left_side();
  inline void set_allocated_left_side(::CaffeGenDef_DataFilterOneSide* left_side);

  // required .CaffeGenDef.DataFilterOneSide right_side = 3;
  inline bool has_right_side() const;
  inline void clear_right_side();
  static const int kRightSideFieldNumber = 3;
  inline const ::CaffeGenDef_DataFilterOneSide& right_side() const;
  inline ::CaffeGenDef_DataFilterOneSide* mutable_right_side();
  inline ::CaffeGenDef_DataFilterOneSide* release_right_side();
  inline void set_allocated_right_side(::CaffeGenDef_DataFilterOneSide* right_side);

  // @@protoc_insertion_point(class_scope:CaffeGenDef.DataFilter)
 private:
  inline void set_has_fmt();
  inline void clear_has_fmt();
  inline void set_has_left_side();
  inline void clear_has_left_side();
  inline void set_has_right_side();
  inline void clear_has_right_side();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::CaffeGenDef_DataFilterOneSide* left_side_;
  ::CaffeGenDef_DataFilterOneSide* right_side_;
  int fmt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_GenDef_2eproto();
  friend void protobuf_AssignDesc_GenDef_2eproto();
  friend void protobuf_ShutdownFile_GenDef_2eproto();

  void InitAsDefaultInstance();
  static CaffeGenDef_DataFilter* default_instance_;
};
// -------------------------------------------------------------------

class CaffeGenDef_DataTranslate : public ::google::protobuf::Message {
 public:
  CaffeGenDef_DataTranslate();
  virtual ~CaffeGenDef_DataTranslate();

  CaffeGenDef_DataTranslate(const CaffeGenDef_DataTranslate& from);

  inline CaffeGenDef_DataTranslate& operator=(const CaffeGenDef_DataTranslate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CaffeGenDef_DataTranslate& default_instance();

  void Swap(CaffeGenDef_DataTranslate* other);

  // implements Message ----------------------------------------------

  CaffeGenDef_DataTranslate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CaffeGenDef_DataTranslate& from);
  void MergeFrom(const CaffeGenDef_DataTranslate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .CaffeGenDef.DataTranslateType translate_type = 1;
  inline bool has_translate_type() const;
  inline void clear_translate_type();
  static const int kTranslateTypeFieldNumber = 1;
  inline ::CaffeGenDef_DataTranslateType translate_type() const;
  inline void set_translate_type(::CaffeGenDef_DataTranslateType value);

  // required string var_name = 2;
  inline bool has_var_name() const;
  inline void clear_var_name();
  static const int kVarNameFieldNumber = 2;
  inline const ::std::string& var_name() const;
  inline void set_var_name(const ::std::string& value);
  inline void set_var_name(const char* value);
  inline void set_var_name(const char* value, size_t size);
  inline ::std::string* mutable_var_name();
  inline ::std::string* release_var_name();
  inline void set_allocated_var_name(::std::string* var_name);

  // required string match_name = 4;
  inline bool has_match_name() const;
  inline void clear_match_name();
  static const int kMatchNameFieldNumber = 4;
  inline const ::std::string& match_name() const;
  inline void set_match_name(const ::std::string& value);
  inline void set_match_name(const char* value);
  inline void set_match_name(const char* value, size_t size);
  inline ::std::string* mutable_match_name();
  inline ::std::string* release_match_name();
  inline void set_allocated_match_name(::std::string* match_name);

  // optional .CaffeGenDef.WordDataType field_type = 6;
  inline bool has_field_type() const;
  inline void clear_field_type();
  static const int kFieldTypeFieldNumber = 6;
  inline ::CaffeGenDef_WordDataType field_type() const;
  inline void set_field_type(::CaffeGenDef_WordDataType value);

  // @@protoc_insertion_point(class_scope:CaffeGenDef.DataTranslate)
 private:
  inline void set_has_translate_type();
  inline void clear_has_translate_type();
  inline void set_has_var_name();
  inline void clear_has_var_name();
  inline void set_has_match_name();
  inline void clear_has_match_name();
  inline void set_has_field_type();
  inline void clear_has_field_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* var_name_;
  int translate_type_;
  int field_type_;
  ::std::string* match_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_GenDef_2eproto();
  friend void protobuf_AssignDesc_GenDef_2eproto();
  friend void protobuf_ShutdownFile_GenDef_2eproto();

  void InitAsDefaultInstance();
  static CaffeGenDef_DataTranslate* default_instance_;
};
// -------------------------------------------------------------------

class CaffeGenDef_NetValue : public ::google::protobuf::Message {
 public:
  CaffeGenDef_NetValue();
  virtual ~CaffeGenDef_NetValue();

  CaffeGenDef_NetValue(const CaffeGenDef_NetValue& from);

  inline CaffeGenDef_NetValue& operator=(const CaffeGenDef_NetValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CaffeGenDef_NetValue& default_instance();

  void Swap(CaffeGenDef_NetValue* other);

  // implements Message ----------------------------------------------

  CaffeGenDef_NetValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CaffeGenDef_NetValue& from);
  void MergeFrom(const CaffeGenDef_NetValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool b_input = 1;
  inline bool has_b_input() const;
  inline void clear_b_input();
  static const int kBInputFieldNumber = 1;
  inline bool b_input() const;
  inline void set_b_input(bool value);

  // required string var_name = 2;
  inline bool has_var_name() const;
  inline void clear_var_name();
  static const int kVarNameFieldNumber = 2;
  inline const ::std::string& var_name() const;
  inline void set_var_name(const ::std::string& value);
  inline void set_var_name(const char* value);
  inline void set_var_name(const char* value, size_t size);
  inline ::std::string* mutable_var_name();
  inline ::std::string* release_var_name();
  inline void set_allocated_var_name(::std::string* var_name);

  // required string var_name_src = 3;
  inline bool has_var_name_src() const;
  inline void clear_var_name_src();
  static const int kVarNameSrcFieldNumber = 3;
  inline const ::std::string& var_name_src() const;
  inline void set_var_name_src(const ::std::string& value);
  inline void set_var_name_src(const char* value);
  inline void set_var_name_src(const char* value, size_t size);
  inline ::std::string* mutable_var_name_src();
  inline ::std::string* release_var_name_src();
  inline void set_allocated_var_name_src(::std::string* var_name_src);

  // required .CaffeGenDef.VarExtractType vet = 4;
  inline bool has_vet() const;
  inline void clear_vet();
  static const int kVetFieldNumber = 4;
  inline ::CaffeGenDef_VarExtractType vet() const;
  inline void set_vet(::CaffeGenDef_VarExtractType value);

  // required string vec_table_name = 5;
  inline bool has_vec_table_name() const;
  inline void clear_vec_table_name();
  static const int kVecTableNameFieldNumber = 5;
  inline const ::std::string& vec_table_name() const;
  inline void set_vec_table_name(const ::std::string& value);
  inline void set_vec_table_name(const char* value);
  inline void set_vec_table_name(const char* value, size_t size);
  inline ::std::string* mutable_vec_table_name();
  inline ::std::string* release_vec_table_name();
  inline void set_allocated_vec_table_name(::std::string* vec_table_name);

  // optional int32 var_src_idx = 6;
  inline bool has_var_src_idx() const;
  inline void clear_var_src_idx();
  static const int kVarSrcIdxFieldNumber = 6;
  inline ::google::protobuf::int32 var_src_idx() const;
  inline void set_var_src_idx(::google::protobuf::int32 value);

  // optional int32 vec_table_idx = 7;
  inline bool has_vec_table_idx() const;
  inline void clear_vec_table_idx();
  static const int kVecTableIdxFieldNumber = 7;
  inline ::google::protobuf::int32 vec_table_idx() const;
  inline void set_vec_table_idx(::google::protobuf::int32 value);

  // optional bool b_can_replace = 8;
  inline bool has_b_can_replace() const;
  inline void clear_b_can_replace();
  static const int kBCanReplaceFieldNumber = 8;
  inline bool b_can_replace() const;
  inline void set_b_can_replace(bool value);

  // optional int32 max_instances = 9;
  inline bool has_max_instances() const;
  inline void clear_max_instances();
  static const int kMaxInstancesFieldNumber = 9;
  inline ::google::protobuf::int32 max_instances() const;
  inline void set_max_instances(::google::protobuf::int32 value);

  // optional float replace_prob = 10;
  inline bool has_replace_prob() const;
  inline void clear_replace_prob();
  static const int kReplaceProbFieldNumber = 10;
  inline float replace_prob() const;
  inline void set_replace_prob(float value);

  // @@protoc_insertion_point(class_scope:CaffeGenDef.NetValue)
 private:
  inline void set_has_b_input();
  inline void clear_has_b_input();
  inline void set_has_var_name();
  inline void clear_has_var_name();
  inline void set_has_var_name_src();
  inline void clear_has_var_name_src();
  inline void set_has_vet();
  inline void clear_has_vet();
  inline void set_has_vec_table_name();
  inline void clear_has_vec_table_name();
  inline void set_has_var_src_idx();
  inline void clear_has_var_src_idx();
  inline void set_has_vec_table_idx();
  inline void clear_has_vec_table_idx();
  inline void set_has_b_can_replace();
  inline void clear_has_b_can_replace();
  inline void set_has_max_instances();
  inline void clear_has_max_instances();
  inline void set_has_replace_prob();
  inline void clear_has_replace_prob();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* var_name_;
  ::std::string* var_name_src_;
  int vet_;
  bool b_input_;
  bool b_can_replace_;
  ::std::string* vec_table_name_;
  ::google::protobuf::int32 var_src_idx_;
  ::google::protobuf::int32 vec_table_idx_;
  ::google::protobuf::int32 max_instances_;
  float replace_prob_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_GenDef_2eproto();
  friend void protobuf_AssignDesc_GenDef_2eproto();
  friend void protobuf_ShutdownFile_GenDef_2eproto();

  void InitAsDefaultInstance();
  static CaffeGenDef_NetValue* default_instance_;
};
// -------------------------------------------------------------------

class CaffeGenDef : public ::google::protobuf::Message {
 public:
  CaffeGenDef();
  virtual ~CaffeGenDef();

  CaffeGenDef(const CaffeGenDef& from);

  inline CaffeGenDef& operator=(const CaffeGenDef& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CaffeGenDef& default_instance();

  void Swap(CaffeGenDef* other);

  // implements Message ----------------------------------------------

  CaffeGenDef* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CaffeGenDef& from);
  void MergeFrom(const CaffeGenDef& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CaffeGenDef_DataAccess DataAccess;
  typedef CaffeGenDef_DataFilterOneSide DataFilterOneSide;
  typedef CaffeGenDef_DataFilter DataFilter;
  typedef CaffeGenDef_DataTranslate DataTranslate;
  typedef CaffeGenDef_NetValue NetValue;

  typedef CaffeGenDef_AccessType AccessType;
  static const AccessType ACCESS_TYPE_DEP = CaffeGenDef_AccessType_ACCESS_TYPE_DEP;
  static const AccessType ACCESS_TYPE_WORD = CaffeGenDef_AccessType_ACCESS_TYPE_WORD;
  static inline bool AccessType_IsValid(int value) {
    return CaffeGenDef_AccessType_IsValid(value);
  }
  static const AccessType AccessType_MIN =
    CaffeGenDef_AccessType_AccessType_MIN;
  static const AccessType AccessType_MAX =
    CaffeGenDef_AccessType_AccessType_MAX;
  static const int AccessType_ARRAYSIZE =
    CaffeGenDef_AccessType_AccessType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  AccessType_descriptor() {
    return CaffeGenDef_AccessType_descriptor();
  }
  static inline const ::std::string& AccessType_Name(AccessType value) {
    return CaffeGenDef_AccessType_Name(value);
  }
  static inline bool AccessType_Parse(const ::std::string& name,
      AccessType* value) {
    return CaffeGenDef_AccessType_Parse(name, value);
  }

  typedef CaffeGenDef_MatchType MatchType;
  static const MatchType mtDEP_RDID = CaffeGenDef_MatchType_mtDEP_RDID;
  static const MatchType mtDEP_GOV_RWID = CaffeGenDef_MatchType_mtDEP_GOV_RWID;
  static const MatchType mtDEP_DEP_RWID = CaffeGenDef_MatchType_mtDEP_DEP_RWID;
  static const MatchType mtWORD_RWID = CaffeGenDef_MatchType_mtWORD_RWID;
  static const MatchType mtWORD_CORE = CaffeGenDef_MatchType_mtWORD_CORE;
  static const MatchType mtWORD_WORD = CaffeGenDef_MatchType_mtWORD_WORD;
  static const MatchType mtWORD_POS = CaffeGenDef_MatchType_mtWORD_POS;
  static inline bool MatchType_IsValid(int value) {
    return CaffeGenDef_MatchType_IsValid(value);
  }
  static const MatchType MatchType_MIN =
    CaffeGenDef_MatchType_MatchType_MIN;
  static const MatchType MatchType_MAX =
    CaffeGenDef_MatchType_MatchType_MAX;
  static const int MatchType_ARRAYSIZE =
    CaffeGenDef_MatchType_MatchType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MatchType_descriptor() {
    return CaffeGenDef_MatchType_descriptor();
  }
  static inline const ::std::string& MatchType_Name(MatchType value) {
    return CaffeGenDef_MatchType_Name(value);
  }
  static inline bool MatchType_Parse(const ::std::string& name,
      MatchType* value) {
    return CaffeGenDef_MatchType_Parse(name, value);
  }

  typedef CaffeGenDef_FilterMatchType FilterMatchType;
  static const FilterMatchType fmtEqual = CaffeGenDef_FilterMatchType_fmtEqual;
  static const FilterMatchType fmtClose = CaffeGenDef_FilterMatchType_fmtClose;
  static inline bool FilterMatchType_IsValid(int value) {
    return CaffeGenDef_FilterMatchType_IsValid(value);
  }
  static const FilterMatchType FilterMatchType_MIN =
    CaffeGenDef_FilterMatchType_FilterMatchType_MIN;
  static const FilterMatchType FilterMatchType_MAX =
    CaffeGenDef_FilterMatchType_FilterMatchType_MAX;
  static const int FilterMatchType_ARRAYSIZE =
    CaffeGenDef_FilterMatchType_FilterMatchType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FilterMatchType_descriptor() {
    return CaffeGenDef_FilterMatchType_descriptor();
  }
  static inline const ::std::string& FilterMatchType_Name(FilterMatchType value) {
    return CaffeGenDef_FilterMatchType_Name(value);
  }
  static inline bool FilterMatchType_Parse(const ::std::string& name,
      FilterMatchType* value) {
    return CaffeGenDef_FilterMatchType_Parse(name, value);
  }

  typedef CaffeGenDef_WordDataType WordDataType;
  static const WordDataType wdtWORD = CaffeGenDef_WordDataType_wdtWORD;
  static const WordDataType wdtPOS = CaffeGenDef_WordDataType_wdtPOS;
  static const WordDataType wdtCORE = CaffeGenDef_WordDataType_wdtCORE;
  static inline bool WordDataType_IsValid(int value) {
    return CaffeGenDef_WordDataType_IsValid(value);
  }
  static const WordDataType WordDataType_MIN =
    CaffeGenDef_WordDataType_WordDataType_MIN;
  static const WordDataType WordDataType_MAX =
    CaffeGenDef_WordDataType_WordDataType_MAX;
  static const int WordDataType_ARRAYSIZE =
    CaffeGenDef_WordDataType_WordDataType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  WordDataType_descriptor() {
    return CaffeGenDef_WordDataType_descriptor();
  }
  static inline const ::std::string& WordDataType_Name(WordDataType value) {
    return CaffeGenDef_WordDataType_Name(value);
  }
  static inline bool WordDataType_Parse(const ::std::string& name,
      WordDataType* value) {
    return CaffeGenDef_WordDataType_Parse(name, value);
  }

  typedef CaffeGenDef_DataTranslateType DataTranslateType;
  static const DataTranslateType dttRWID_TO_WORD = CaffeGenDef_DataTranslateType_dttRWID_TO_WORD;
  static const DataTranslateType dttRWID_TO_COREF = CaffeGenDef_DataTranslateType_dttRWID_TO_COREF;
  static const DataTranslateType dttRWID_TO_RDID = CaffeGenDef_DataTranslateType_dttRWID_TO_RDID;
  static const DataTranslateType dttRDID_TO_DEP_NAME = CaffeGenDef_DataTranslateType_dttRDID_TO_DEP_NAME;
  static const DataTranslateType dttRDID_TO_GOV_RWID = CaffeGenDef_DataTranslateType_dttRDID_TO_GOV_RWID;
  static const DataTranslateType dttRDID_TO_DEP_RWID = CaffeGenDef_DataTranslateType_dttRDID_TO_DEP_RWID;
  static inline bool DataTranslateType_IsValid(int value) {
    return CaffeGenDef_DataTranslateType_IsValid(value);
  }
  static const DataTranslateType DataTranslateType_MIN =
    CaffeGenDef_DataTranslateType_DataTranslateType_MIN;
  static const DataTranslateType DataTranslateType_MAX =
    CaffeGenDef_DataTranslateType_DataTranslateType_MAX;
  static const int DataTranslateType_ARRAYSIZE =
    CaffeGenDef_DataTranslateType_DataTranslateType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DataTranslateType_descriptor() {
    return CaffeGenDef_DataTranslateType_descriptor();
  }
  static inline const ::std::string& DataTranslateType_Name(DataTranslateType value) {
    return CaffeGenDef_DataTranslateType_Name(value);
  }
  static inline bool DataTranslateType_Parse(const ::std::string& name,
      DataTranslateType* value) {
    return CaffeGenDef_DataTranslateType_Parse(name, value);
  }

  typedef CaffeGenDef_VarExtractType VarExtractType;
  static const VarExtractType vetPOS = CaffeGenDef_VarExtractType_vetPOS;
  static const VarExtractType vetWordCore = CaffeGenDef_VarExtractType_vetWordCore;
  static const VarExtractType vetWord = CaffeGenDef_VarExtractType_vetWord;
  static const VarExtractType vetDepName = CaffeGenDef_VarExtractType_vetDepName;
  static const VarExtractType vetDummy = CaffeGenDef_VarExtractType_vetDummy;
  static const VarExtractType vetNumDepGovs = CaffeGenDef_VarExtractType_vetNumDepGovs;
  static inline bool VarExtractType_IsValid(int value) {
    return CaffeGenDef_VarExtractType_IsValid(value);
  }
  static const VarExtractType VarExtractType_MIN =
    CaffeGenDef_VarExtractType_VarExtractType_MIN;
  static const VarExtractType VarExtractType_MAX =
    CaffeGenDef_VarExtractType_VarExtractType_MAX;
  static const int VarExtractType_ARRAYSIZE =
    CaffeGenDef_VarExtractType_VarExtractType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  VarExtractType_descriptor() {
    return CaffeGenDef_VarExtractType_descriptor();
  }
  static inline const ::std::string& VarExtractType_Name(VarExtractType value) {
    return CaffeGenDef_VarExtractType_Name(value);
  }
  static inline bool VarExtractType_Parse(const ::std::string& name,
      VarExtractType* value) {
    return CaffeGenDef_VarExtractType_Parse(name, value);
  }

  typedef CaffeGenDef_NetEndType NetEndType;
  static const NetEndType END_VALID = CaffeGenDef_NetEndType_END_VALID;
  static const NetEndType END_ONE_HOT = CaffeGenDef_NetEndType_END_ONE_HOT;
  static const NetEndType END_MULTI_HOT = CaffeGenDef_NetEndType_END_MULTI_HOT;
  static inline bool NetEndType_IsValid(int value) {
    return CaffeGenDef_NetEndType_IsValid(value);
  }
  static const NetEndType NetEndType_MIN =
    CaffeGenDef_NetEndType_NetEndType_MIN;
  static const NetEndType NetEndType_MAX =
    CaffeGenDef_NetEndType_NetEndType_MAX;
  static const int NetEndType_ARRAYSIZE =
    CaffeGenDef_NetEndType_NetEndType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  NetEndType_descriptor() {
    return CaffeGenDef_NetEndType_descriptor();
  }
  static inline const ::std::string& NetEndType_Name(NetEndType value) {
    return CaffeGenDef_NetEndType_Name(value);
  }
  static inline bool NetEndType_Parse(const ::std::string& name,
      NetEndType* value) {
    return CaffeGenDef_NetEndType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 NumSentenceRecsToSearch = 2;
  inline bool has_numsentencerecstosearch() const;
  inline void clear_numsentencerecstosearch();
  static const int kNumSentenceRecsToSearchFieldNumber = 2;
  inline ::google::protobuf::int32 numsentencerecstosearch() const;
  inline void set_numsentencerecstosearch(::google::protobuf::int32 value);

  // repeated .CaffeGenDef.DataAccess access_fields = 3;
  inline int access_fields_size() const;
  inline void clear_access_fields();
  static const int kAccessFieldsFieldNumber = 3;
  inline const ::CaffeGenDef_DataAccess& access_fields(int index) const;
  inline ::CaffeGenDef_DataAccess* mutable_access_fields(int index);
  inline ::CaffeGenDef_DataAccess* add_access_fields();
  inline const ::google::protobuf::RepeatedPtrField< ::CaffeGenDef_DataAccess >&
      access_fields() const;
  inline ::google::protobuf::RepeatedPtrField< ::CaffeGenDef_DataAccess >*
      mutable_access_fields();

  // repeated .CaffeGenDef.DataFilter data_filters = 4;
  inline int data_filters_size() const;
  inline void clear_data_filters();
  static const int kDataFiltersFieldNumber = 4;
  inline const ::CaffeGenDef_DataFilter& data_filters(int index) const;
  inline ::CaffeGenDef_DataFilter* mutable_data_filters(int index);
  inline ::CaffeGenDef_DataFilter* add_data_filters();
  inline const ::google::protobuf::RepeatedPtrField< ::CaffeGenDef_DataFilter >&
      data_filters() const;
  inline ::google::protobuf::RepeatedPtrField< ::CaffeGenDef_DataFilter >*
      mutable_data_filters();

  // repeated .CaffeGenDef.DataTranslate data_translates = 5;
  inline int data_translates_size() const;
  inline void clear_data_translates();
  static const int kDataTranslatesFieldNumber = 5;
  inline const ::CaffeGenDef_DataTranslate& data_translates(int index) const;
  inline ::CaffeGenDef_DataTranslate* mutable_data_translates(int index);
  inline ::CaffeGenDef_DataTranslate* add_data_translates();
  inline const ::google::protobuf::RepeatedPtrField< ::CaffeGenDef_DataTranslate >&
      data_translates() const;
  inline ::google::protobuf::RepeatedPtrField< ::CaffeGenDef_DataTranslate >*
      mutable_data_translates();

  // repeated .CaffeGenDef.NetValue net_values = 6;
  inline int net_values_size() const;
  inline void clear_net_values();
  static const int kNetValuesFieldNumber = 6;
  inline const ::CaffeGenDef_NetValue& net_values(int index) const;
  inline ::CaffeGenDef_NetValue* mutable_net_values(int index);
  inline ::CaffeGenDef_NetValue* add_net_values();
  inline const ::google::protobuf::RepeatedPtrField< ::CaffeGenDef_NetValue >&
      net_values() const;
  inline ::google::protobuf::RepeatedPtrField< ::CaffeGenDef_NetValue >*
      mutable_net_values();

  // required string files_core_dir = 8;
  inline bool has_files_core_dir() const;
  inline void clear_files_core_dir();
  static const int kFilesCoreDirFieldNumber = 8;
  inline const ::std::string& files_core_dir() const;
  inline void set_files_core_dir(const ::std::string& value);
  inline void set_files_core_dir(const char* value);
  inline void set_files_core_dir(const char* value, size_t size);
  inline ::std::string* mutable_files_core_dir();
  inline ::std::string* release_files_core_dir();
  inline void set_allocated_files_core_dir(::std::string* files_core_dir);

  // required string test_list_file_name = 9;
  inline bool has_test_list_file_name() const;
  inline void clear_test_list_file_name();
  static const int kTestListFileNameFieldNumber = 9;
  inline const ::std::string& test_list_file_name() const;
  inline void set_test_list_file_name(const ::std::string& value);
  inline void set_test_list_file_name(const char* value);
  inline void set_test_list_file_name(const char* value, size_t size);
  inline ::std::string* mutable_test_list_file_name();
  inline ::std::string* release_test_list_file_name();
  inline void set_allocated_test_list_file_name(::std::string* test_list_file_name);

  // required string train_list_file_name = 10;
  inline bool has_train_list_file_name() const;
  inline void clear_train_list_file_name();
  static const int kTrainListFileNameFieldNumber = 10;
  inline const ::std::string& train_list_file_name() const;
  inline void set_train_list_file_name(const ::std::string& value);
  inline void set_train_list_file_name(const char* value);
  inline void set_train_list_file_name(const char* value, size_t size);
  inline ::std::string* mutable_train_list_file_name();
  inline ::std::string* release_train_list_file_name();
  inline void set_allocated_train_list_file_name(::std::string* train_list_file_name);

  // required .CaffeGenDef.NetEndType net_end_type = 11;
  inline bool has_net_end_type() const;
  inline void clear_net_end_type();
  static const int kNetEndTypeFieldNumber = 11;
  inline ::CaffeGenDef_NetEndType net_end_type() const;
  inline void set_net_end_type(::CaffeGenDef_NetEndType value);

  // required string proto_file_name = 12;
  inline bool has_proto_file_name() const;
  inline void clear_proto_file_name();
  static const int kProtoFileNameFieldNumber = 12;
  inline const ::std::string& proto_file_name() const;
  inline void set_proto_file_name(const ::std::string& value);
  inline void set_proto_file_name(const char* value);
  inline void set_proto_file_name(const char* value, size_t size);
  inline ::std::string* mutable_proto_file_name();
  inline ::std::string* release_proto_file_name();
  inline void set_allocated_proto_file_name(::std::string* proto_file_name);

  // required string model_file_name = 13;
  inline bool has_model_file_name() const;
  inline void clear_model_file_name();
  static const int kModelFileNameFieldNumber = 13;
  inline const ::std::string& model_file_name() const;
  inline void set_model_file_name(const ::std::string& value);
  inline void set_model_file_name(const char* value);
  inline void set_model_file_name(const char* value, size_t size);
  inline ::std::string* mutable_model_file_name();
  inline ::std::string* release_model_file_name();
  inline void set_allocated_model_file_name(::std::string* model_file_name);

  // required string config_file_name = 14;
  inline bool has_config_file_name() const;
  inline void clear_config_file_name();
  static const int kConfigFileNameFieldNumber = 14;
  inline const ::std::string& config_file_name() const;
  inline void set_config_file_name(const ::std::string& value);
  inline void set_config_file_name(const char* value);
  inline void set_config_file_name(const char* value, size_t size);
  inline ::std::string* mutable_config_file_name();
  inline ::std::string* release_config_file_name();
  inline void set_allocated_config_file_name(::std::string* config_file_name);

  // optional int32 num_accuracy_candidates = 15;
  inline bool has_num_accuracy_candidates() const;
  inline void clear_num_accuracy_candidates();
  static const int kNumAccuracyCandidatesFieldNumber = 15;
  inline ::google::protobuf::int32 num_accuracy_candidates() const;
  inline void set_num_accuracy_candidates(::google::protobuf::int32 value);

  // required string netgen_output_file_name = 18;
  inline bool has_netgen_output_file_name() const;
  inline void clear_netgen_output_file_name();
  static const int kNetgenOutputFileNameFieldNumber = 18;
  inline const ::std::string& netgen_output_file_name() const;
  inline void set_netgen_output_file_name(const ::std::string& value);
  inline void set_netgen_output_file_name(const char* value);
  inline void set_netgen_output_file_name(const char* value, size_t size);
  inline ::std::string* mutable_netgen_output_file_name();
  inline ::std::string* release_netgen_output_file_name();
  inline void set_allocated_netgen_output_file_name(::std::string* netgen_output_file_name);

  // @@protoc_insertion_point(class_scope:CaffeGenDef)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_numsentencerecstosearch();
  inline void clear_has_numsentencerecstosearch();
  inline void set_has_files_core_dir();
  inline void clear_has_files_core_dir();
  inline void set_has_test_list_file_name();
  inline void clear_has_test_list_file_name();
  inline void set_has_train_list_file_name();
  inline void clear_has_train_list_file_name();
  inline void set_has_net_end_type();
  inline void clear_has_net_end_type();
  inline void set_has_proto_file_name();
  inline void clear_has_proto_file_name();
  inline void set_has_model_file_name();
  inline void clear_has_model_file_name();
  inline void set_has_config_file_name();
  inline void clear_has_config_file_name();
  inline void set_has_num_accuracy_candidates();
  inline void clear_has_num_accuracy_candidates();
  inline void set_has_netgen_output_file_name();
  inline void clear_has_netgen_output_file_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::CaffeGenDef_DataAccess > access_fields_;
  ::google::protobuf::RepeatedPtrField< ::CaffeGenDef_DataFilter > data_filters_;
  ::google::protobuf::RepeatedPtrField< ::CaffeGenDef_DataTranslate > data_translates_;
  ::google::protobuf::RepeatedPtrField< ::CaffeGenDef_NetValue > net_values_;
  ::google::protobuf::int32 numsentencerecstosearch_;
  int net_end_type_;
  ::std::string* files_core_dir_;
  ::std::string* test_list_file_name_;
  ::std::string* train_list_file_name_;
  ::std::string* proto_file_name_;
  ::std::string* model_file_name_;
  ::std::string* config_file_name_;
  ::std::string* netgen_output_file_name_;
  ::google::protobuf::int32 num_accuracy_candidates_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  friend void  protobuf_AddDesc_GenDef_2eproto();
  friend void protobuf_AssignDesc_GenDef_2eproto();
  friend void protobuf_ShutdownFile_GenDef_2eproto();

  void InitAsDefaultInstance();
  static CaffeGenDef* default_instance_;
};
// ===================================================================


// ===================================================================

// CaffeGenDef_DataAccess

// required string var_name = 1;
inline bool CaffeGenDef_DataAccess::has_var_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CaffeGenDef_DataAccess::set_has_var_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CaffeGenDef_DataAccess::clear_has_var_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CaffeGenDef_DataAccess::clear_var_name() {
  if (var_name_ != &::google::protobuf::internal::kEmptyString) {
    var_name_->clear();
  }
  clear_has_var_name();
}
inline const ::std::string& CaffeGenDef_DataAccess::var_name() const {
  return *var_name_;
}
inline void CaffeGenDef_DataAccess::set_var_name(const ::std::string& value) {
  set_has_var_name();
  if (var_name_ == &::google::protobuf::internal::kEmptyString) {
    var_name_ = new ::std::string;
  }
  var_name_->assign(value);
}
inline void CaffeGenDef_DataAccess::set_var_name(const char* value) {
  set_has_var_name();
  if (var_name_ == &::google::protobuf::internal::kEmptyString) {
    var_name_ = new ::std::string;
  }
  var_name_->assign(value);
}
inline void CaffeGenDef_DataAccess::set_var_name(const char* value, size_t size) {
  set_has_var_name();
  if (var_name_ == &::google::protobuf::internal::kEmptyString) {
    var_name_ = new ::std::string;
  }
  var_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CaffeGenDef_DataAccess::mutable_var_name() {
  set_has_var_name();
  if (var_name_ == &::google::protobuf::internal::kEmptyString) {
    var_name_ = new ::std::string;
  }
  return var_name_;
}
inline ::std::string* CaffeGenDef_DataAccess::release_var_name() {
  clear_has_var_name();
  if (var_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = var_name_;
    var_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CaffeGenDef_DataAccess::set_allocated_var_name(::std::string* var_name) {
  if (var_name_ != &::google::protobuf::internal::kEmptyString) {
    delete var_name_;
  }
  if (var_name) {
    set_has_var_name();
    var_name_ = var_name;
  } else {
    clear_has_var_name();
    var_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .CaffeGenDef.AccessType access_type = 2;
inline bool CaffeGenDef_DataAccess::has_access_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CaffeGenDef_DataAccess::set_has_access_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CaffeGenDef_DataAccess::clear_has_access_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CaffeGenDef_DataAccess::clear_access_type() {
  access_type_ = 1;
  clear_has_access_type();
}
inline ::CaffeGenDef_AccessType CaffeGenDef_DataAccess::access_type() const {
  return static_cast< ::CaffeGenDef_AccessType >(access_type_);
}
inline void CaffeGenDef_DataAccess::set_access_type(::CaffeGenDef_AccessType value) {
  assert(::CaffeGenDef_AccessType_IsValid(value));
  set_has_access_type();
  access_type_ = value;
}

// optional string dep_type_to_match = 3;
inline bool CaffeGenDef_DataAccess::has_dep_type_to_match() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CaffeGenDef_DataAccess::set_has_dep_type_to_match() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CaffeGenDef_DataAccess::clear_has_dep_type_to_match() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CaffeGenDef_DataAccess::clear_dep_type_to_match() {
  if (dep_type_to_match_ != &::google::protobuf::internal::kEmptyString) {
    dep_type_to_match_->clear();
  }
  clear_has_dep_type_to_match();
}
inline const ::std::string& CaffeGenDef_DataAccess::dep_type_to_match() const {
  return *dep_type_to_match_;
}
inline void CaffeGenDef_DataAccess::set_dep_type_to_match(const ::std::string& value) {
  set_has_dep_type_to_match();
  if (dep_type_to_match_ == &::google::protobuf::internal::kEmptyString) {
    dep_type_to_match_ = new ::std::string;
  }
  dep_type_to_match_->assign(value);
}
inline void CaffeGenDef_DataAccess::set_dep_type_to_match(const char* value) {
  set_has_dep_type_to_match();
  if (dep_type_to_match_ == &::google::protobuf::internal::kEmptyString) {
    dep_type_to_match_ = new ::std::string;
  }
  dep_type_to_match_->assign(value);
}
inline void CaffeGenDef_DataAccess::set_dep_type_to_match(const char* value, size_t size) {
  set_has_dep_type_to_match();
  if (dep_type_to_match_ == &::google::protobuf::internal::kEmptyString) {
    dep_type_to_match_ = new ::std::string;
  }
  dep_type_to_match_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CaffeGenDef_DataAccess::mutable_dep_type_to_match() {
  set_has_dep_type_to_match();
  if (dep_type_to_match_ == &::google::protobuf::internal::kEmptyString) {
    dep_type_to_match_ = new ::std::string;
  }
  return dep_type_to_match_;
}
inline ::std::string* CaffeGenDef_DataAccess::release_dep_type_to_match() {
  clear_has_dep_type_to_match();
  if (dep_type_to_match_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dep_type_to_match_;
    dep_type_to_match_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CaffeGenDef_DataAccess::set_allocated_dep_type_to_match(::std::string* dep_type_to_match) {
  if (dep_type_to_match_ != &::google::protobuf::internal::kEmptyString) {
    delete dep_type_to_match_;
  }
  if (dep_type_to_match) {
    set_has_dep_type_to_match();
    dep_type_to_match_ = dep_type_to_match;
  } else {
    clear_has_dep_type_to_match();
    dep_type_to_match_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string POS_to_match = 4;
inline bool CaffeGenDef_DataAccess::has_pos_to_match() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CaffeGenDef_DataAccess::set_has_pos_to_match() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CaffeGenDef_DataAccess::clear_has_pos_to_match() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CaffeGenDef_DataAccess::clear_pos_to_match() {
  if (pos_to_match_ != &::google::protobuf::internal::kEmptyString) {
    pos_to_match_->clear();
  }
  clear_has_pos_to_match();
}
inline const ::std::string& CaffeGenDef_DataAccess::pos_to_match() const {
  return *pos_to_match_;
}
inline void CaffeGenDef_DataAccess::set_pos_to_match(const ::std::string& value) {
  set_has_pos_to_match();
  if (pos_to_match_ == &::google::protobuf::internal::kEmptyString) {
    pos_to_match_ = new ::std::string;
  }
  pos_to_match_->assign(value);
}
inline void CaffeGenDef_DataAccess::set_pos_to_match(const char* value) {
  set_has_pos_to_match();
  if (pos_to_match_ == &::google::protobuf::internal::kEmptyString) {
    pos_to_match_ = new ::std::string;
  }
  pos_to_match_->assign(value);
}
inline void CaffeGenDef_DataAccess::set_pos_to_match(const char* value, size_t size) {
  set_has_pos_to_match();
  if (pos_to_match_ == &::google::protobuf::internal::kEmptyString) {
    pos_to_match_ = new ::std::string;
  }
  pos_to_match_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CaffeGenDef_DataAccess::mutable_pos_to_match() {
  set_has_pos_to_match();
  if (pos_to_match_ == &::google::protobuf::internal::kEmptyString) {
    pos_to_match_ = new ::std::string;
  }
  return pos_to_match_;
}
inline ::std::string* CaffeGenDef_DataAccess::release_pos_to_match() {
  clear_has_pos_to_match();
  if (pos_to_match_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pos_to_match_;
    pos_to_match_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CaffeGenDef_DataAccess::set_allocated_pos_to_match(::std::string* pos_to_match) {
  if (pos_to_match_ != &::google::protobuf::internal::kEmptyString) {
    delete pos_to_match_;
  }
  if (pos_to_match) {
    set_has_pos_to_match();
    pos_to_match_ = pos_to_match;
  } else {
    clear_has_pos_to_match();
    pos_to_match_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 var_idx = 5;
inline bool CaffeGenDef_DataAccess::has_var_idx() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CaffeGenDef_DataAccess::set_has_var_idx() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CaffeGenDef_DataAccess::clear_has_var_idx() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CaffeGenDef_DataAccess::clear_var_idx() {
  var_idx_ = 0;
  clear_has_var_idx();
}
inline ::google::protobuf::int32 CaffeGenDef_DataAccess::var_idx() const {
  return var_idx_;
}
inline void CaffeGenDef_DataAccess::set_var_idx(::google::protobuf::int32 value) {
  set_has_var_idx();
  var_idx_ = value;
}

// optional int32 max_srec_beyond = 11;
inline bool CaffeGenDef_DataAccess::has_max_srec_beyond() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CaffeGenDef_DataAccess::set_has_max_srec_beyond() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CaffeGenDef_DataAccess::clear_has_max_srec_beyond() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CaffeGenDef_DataAccess::clear_max_srec_beyond() {
  max_srec_beyond_ = 0;
  clear_has_max_srec_beyond();
}
inline ::google::protobuf::int32 CaffeGenDef_DataAccess::max_srec_beyond() const {
  return max_srec_beyond_;
}
inline void CaffeGenDef_DataAccess::set_max_srec_beyond(::google::protobuf::int32 value) {
  set_has_max_srec_beyond();
  max_srec_beyond_ = value;
}

// optional int32 min_srec_beyond = 12;
inline bool CaffeGenDef_DataAccess::has_min_srec_beyond() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CaffeGenDef_DataAccess::set_has_min_srec_beyond() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CaffeGenDef_DataAccess::clear_has_min_srec_beyond() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CaffeGenDef_DataAccess::clear_min_srec_beyond() {
  min_srec_beyond_ = 0;
  clear_has_min_srec_beyond();
}
inline ::google::protobuf::int32 CaffeGenDef_DataAccess::min_srec_beyond() const {
  return min_srec_beyond_;
}
inline void CaffeGenDef_DataAccess::set_min_srec_beyond(::google::protobuf::int32 value) {
  set_has_min_srec_beyond();
  min_srec_beyond_ = value;
}

// -------------------------------------------------------------------

// CaffeGenDef_DataFilterOneSide

// required string var_name_src = 1;
inline bool CaffeGenDef_DataFilterOneSide::has_var_name_src() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CaffeGenDef_DataFilterOneSide::set_has_var_name_src() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CaffeGenDef_DataFilterOneSide::clear_has_var_name_src() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CaffeGenDef_DataFilterOneSide::clear_var_name_src() {
  if (var_name_src_ != &::google::protobuf::internal::kEmptyString) {
    var_name_src_->clear();
  }
  clear_has_var_name_src();
}
inline const ::std::string& CaffeGenDef_DataFilterOneSide::var_name_src() const {
  return *var_name_src_;
}
inline void CaffeGenDef_DataFilterOneSide::set_var_name_src(const ::std::string& value) {
  set_has_var_name_src();
  if (var_name_src_ == &::google::protobuf::internal::kEmptyString) {
    var_name_src_ = new ::std::string;
  }
  var_name_src_->assign(value);
}
inline void CaffeGenDef_DataFilterOneSide::set_var_name_src(const char* value) {
  set_has_var_name_src();
  if (var_name_src_ == &::google::protobuf::internal::kEmptyString) {
    var_name_src_ = new ::std::string;
  }
  var_name_src_->assign(value);
}
inline void CaffeGenDef_DataFilterOneSide::set_var_name_src(const char* value, size_t size) {
  set_has_var_name_src();
  if (var_name_src_ == &::google::protobuf::internal::kEmptyString) {
    var_name_src_ = new ::std::string;
  }
  var_name_src_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CaffeGenDef_DataFilterOneSide::mutable_var_name_src() {
  set_has_var_name_src();
  if (var_name_src_ == &::google::protobuf::internal::kEmptyString) {
    var_name_src_ = new ::std::string;
  }
  return var_name_src_;
}
inline ::std::string* CaffeGenDef_DataFilterOneSide::release_var_name_src() {
  clear_has_var_name_src();
  if (var_name_src_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = var_name_src_;
    var_name_src_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CaffeGenDef_DataFilterOneSide::set_allocated_var_name_src(::std::string* var_name_src) {
  if (var_name_src_ != &::google::protobuf::internal::kEmptyString) {
    delete var_name_src_;
  }
  if (var_name_src) {
    set_has_var_name_src();
    var_name_src_ = var_name_src;
  } else {
    clear_has_var_name_src();
    var_name_src_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .CaffeGenDef.MatchType mt = 2;
inline bool CaffeGenDef_DataFilterOneSide::has_mt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CaffeGenDef_DataFilterOneSide::set_has_mt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CaffeGenDef_DataFilterOneSide::clear_has_mt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CaffeGenDef_DataFilterOneSide::clear_mt() {
  mt_ = 1;
  clear_has_mt();
}
inline ::CaffeGenDef_MatchType CaffeGenDef_DataFilterOneSide::mt() const {
  return static_cast< ::CaffeGenDef_MatchType >(mt_);
}
inline void CaffeGenDef_DataFilterOneSide::set_mt(::CaffeGenDef_MatchType value) {
  assert(::CaffeGenDef_MatchType_IsValid(value));
  set_has_mt();
  mt_ = value;
}

// optional int32 var_src_idx = 3;
inline bool CaffeGenDef_DataFilterOneSide::has_var_src_idx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CaffeGenDef_DataFilterOneSide::set_has_var_src_idx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CaffeGenDef_DataFilterOneSide::clear_has_var_src_idx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CaffeGenDef_DataFilterOneSide::clear_var_src_idx() {
  var_src_idx_ = 0;
  clear_has_var_src_idx();
}
inline ::google::protobuf::int32 CaffeGenDef_DataFilterOneSide::var_src_idx() const {
  return var_src_idx_;
}
inline void CaffeGenDef_DataFilterOneSide::set_var_src_idx(::google::protobuf::int32 value) {
  set_has_var_src_idx();
  var_src_idx_ = value;
}

// -------------------------------------------------------------------

// CaffeGenDef_DataFilter

// optional .CaffeGenDef.FilterMatchType fmt = 1;
inline bool CaffeGenDef_DataFilter::has_fmt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CaffeGenDef_DataFilter::set_has_fmt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CaffeGenDef_DataFilter::clear_has_fmt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CaffeGenDef_DataFilter::clear_fmt() {
  fmt_ = 1;
  clear_has_fmt();
}
inline ::CaffeGenDef_FilterMatchType CaffeGenDef_DataFilter::fmt() const {
  return static_cast< ::CaffeGenDef_FilterMatchType >(fmt_);
}
inline void CaffeGenDef_DataFilter::set_fmt(::CaffeGenDef_FilterMatchType value) {
  assert(::CaffeGenDef_FilterMatchType_IsValid(value));
  set_has_fmt();
  fmt_ = value;
}

// required .CaffeGenDef.DataFilterOneSide left_side = 2;
inline bool CaffeGenDef_DataFilter::has_left_side() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CaffeGenDef_DataFilter::set_has_left_side() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CaffeGenDef_DataFilter::clear_has_left_side() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CaffeGenDef_DataFilter::clear_left_side() {
  if (left_side_ != NULL) left_side_->::CaffeGenDef_DataFilterOneSide::Clear();
  clear_has_left_side();
}
inline const ::CaffeGenDef_DataFilterOneSide& CaffeGenDef_DataFilter::left_side() const {
  return left_side_ != NULL ? *left_side_ : *default_instance_->left_side_;
}
inline ::CaffeGenDef_DataFilterOneSide* CaffeGenDef_DataFilter::mutable_left_side() {
  set_has_left_side();
  if (left_side_ == NULL) left_side_ = new ::CaffeGenDef_DataFilterOneSide;
  return left_side_;
}
inline ::CaffeGenDef_DataFilterOneSide* CaffeGenDef_DataFilter::release_left_side() {
  clear_has_left_side();
  ::CaffeGenDef_DataFilterOneSide* temp = left_side_;
  left_side_ = NULL;
  return temp;
}
inline void CaffeGenDef_DataFilter::set_allocated_left_side(::CaffeGenDef_DataFilterOneSide* left_side) {
  delete left_side_;
  left_side_ = left_side;
  if (left_side) {
    set_has_left_side();
  } else {
    clear_has_left_side();
  }
}

// required .CaffeGenDef.DataFilterOneSide right_side = 3;
inline bool CaffeGenDef_DataFilter::has_right_side() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CaffeGenDef_DataFilter::set_has_right_side() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CaffeGenDef_DataFilter::clear_has_right_side() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CaffeGenDef_DataFilter::clear_right_side() {
  if (right_side_ != NULL) right_side_->::CaffeGenDef_DataFilterOneSide::Clear();
  clear_has_right_side();
}
inline const ::CaffeGenDef_DataFilterOneSide& CaffeGenDef_DataFilter::right_side() const {
  return right_side_ != NULL ? *right_side_ : *default_instance_->right_side_;
}
inline ::CaffeGenDef_DataFilterOneSide* CaffeGenDef_DataFilter::mutable_right_side() {
  set_has_right_side();
  if (right_side_ == NULL) right_side_ = new ::CaffeGenDef_DataFilterOneSide;
  return right_side_;
}
inline ::CaffeGenDef_DataFilterOneSide* CaffeGenDef_DataFilter::release_right_side() {
  clear_has_right_side();
  ::CaffeGenDef_DataFilterOneSide* temp = right_side_;
  right_side_ = NULL;
  return temp;
}
inline void CaffeGenDef_DataFilter::set_allocated_right_side(::CaffeGenDef_DataFilterOneSide* right_side) {
  delete right_side_;
  right_side_ = right_side;
  if (right_side) {
    set_has_right_side();
  } else {
    clear_has_right_side();
  }
}

// -------------------------------------------------------------------

// CaffeGenDef_DataTranslate

// required .CaffeGenDef.DataTranslateType translate_type = 1;
inline bool CaffeGenDef_DataTranslate::has_translate_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CaffeGenDef_DataTranslate::set_has_translate_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CaffeGenDef_DataTranslate::clear_has_translate_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CaffeGenDef_DataTranslate::clear_translate_type() {
  translate_type_ = 1;
  clear_has_translate_type();
}
inline ::CaffeGenDef_DataTranslateType CaffeGenDef_DataTranslate::translate_type() const {
  return static_cast< ::CaffeGenDef_DataTranslateType >(translate_type_);
}
inline void CaffeGenDef_DataTranslate::set_translate_type(::CaffeGenDef_DataTranslateType value) {
  assert(::CaffeGenDef_DataTranslateType_IsValid(value));
  set_has_translate_type();
  translate_type_ = value;
}

// required string var_name = 2;
inline bool CaffeGenDef_DataTranslate::has_var_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CaffeGenDef_DataTranslate::set_has_var_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CaffeGenDef_DataTranslate::clear_has_var_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CaffeGenDef_DataTranslate::clear_var_name() {
  if (var_name_ != &::google::protobuf::internal::kEmptyString) {
    var_name_->clear();
  }
  clear_has_var_name();
}
inline const ::std::string& CaffeGenDef_DataTranslate::var_name() const {
  return *var_name_;
}
inline void CaffeGenDef_DataTranslate::set_var_name(const ::std::string& value) {
  set_has_var_name();
  if (var_name_ == &::google::protobuf::internal::kEmptyString) {
    var_name_ = new ::std::string;
  }
  var_name_->assign(value);
}
inline void CaffeGenDef_DataTranslate::set_var_name(const char* value) {
  set_has_var_name();
  if (var_name_ == &::google::protobuf::internal::kEmptyString) {
    var_name_ = new ::std::string;
  }
  var_name_->assign(value);
}
inline void CaffeGenDef_DataTranslate::set_var_name(const char* value, size_t size) {
  set_has_var_name();
  if (var_name_ == &::google::protobuf::internal::kEmptyString) {
    var_name_ = new ::std::string;
  }
  var_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CaffeGenDef_DataTranslate::mutable_var_name() {
  set_has_var_name();
  if (var_name_ == &::google::protobuf::internal::kEmptyString) {
    var_name_ = new ::std::string;
  }
  return var_name_;
}
inline ::std::string* CaffeGenDef_DataTranslate::release_var_name() {
  clear_has_var_name();
  if (var_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = var_name_;
    var_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CaffeGenDef_DataTranslate::set_allocated_var_name(::std::string* var_name) {
  if (var_name_ != &::google::protobuf::internal::kEmptyString) {
    delete var_name_;
  }
  if (var_name) {
    set_has_var_name();
    var_name_ = var_name;
  } else {
    clear_has_var_name();
    var_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string match_name = 4;
inline bool CaffeGenDef_DataTranslate::has_match_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CaffeGenDef_DataTranslate::set_has_match_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CaffeGenDef_DataTranslate::clear_has_match_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CaffeGenDef_DataTranslate::clear_match_name() {
  if (match_name_ != &::google::protobuf::internal::kEmptyString) {
    match_name_->clear();
  }
  clear_has_match_name();
}
inline const ::std::string& CaffeGenDef_DataTranslate::match_name() const {
  return *match_name_;
}
inline void CaffeGenDef_DataTranslate::set_match_name(const ::std::string& value) {
  set_has_match_name();
  if (match_name_ == &::google::protobuf::internal::kEmptyString) {
    match_name_ = new ::std::string;
  }
  match_name_->assign(value);
}
inline void CaffeGenDef_DataTranslate::set_match_name(const char* value) {
  set_has_match_name();
  if (match_name_ == &::google::protobuf::internal::kEmptyString) {
    match_name_ = new ::std::string;
  }
  match_name_->assign(value);
}
inline void CaffeGenDef_DataTranslate::set_match_name(const char* value, size_t size) {
  set_has_match_name();
  if (match_name_ == &::google::protobuf::internal::kEmptyString) {
    match_name_ = new ::std::string;
  }
  match_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CaffeGenDef_DataTranslate::mutable_match_name() {
  set_has_match_name();
  if (match_name_ == &::google::protobuf::internal::kEmptyString) {
    match_name_ = new ::std::string;
  }
  return match_name_;
}
inline ::std::string* CaffeGenDef_DataTranslate::release_match_name() {
  clear_has_match_name();
  if (match_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = match_name_;
    match_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CaffeGenDef_DataTranslate::set_allocated_match_name(::std::string* match_name) {
  if (match_name_ != &::google::protobuf::internal::kEmptyString) {
    delete match_name_;
  }
  if (match_name) {
    set_has_match_name();
    match_name_ = match_name;
  } else {
    clear_has_match_name();
    match_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .CaffeGenDef.WordDataType field_type = 6;
inline bool CaffeGenDef_DataTranslate::has_field_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CaffeGenDef_DataTranslate::set_has_field_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CaffeGenDef_DataTranslate::clear_has_field_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CaffeGenDef_DataTranslate::clear_field_type() {
  field_type_ = 1;
  clear_has_field_type();
}
inline ::CaffeGenDef_WordDataType CaffeGenDef_DataTranslate::field_type() const {
  return static_cast< ::CaffeGenDef_WordDataType >(field_type_);
}
inline void CaffeGenDef_DataTranslate::set_field_type(::CaffeGenDef_WordDataType value) {
  assert(::CaffeGenDef_WordDataType_IsValid(value));
  set_has_field_type();
  field_type_ = value;
}

// -------------------------------------------------------------------

// CaffeGenDef_NetValue

// required bool b_input = 1;
inline bool CaffeGenDef_NetValue::has_b_input() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CaffeGenDef_NetValue::set_has_b_input() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CaffeGenDef_NetValue::clear_has_b_input() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CaffeGenDef_NetValue::clear_b_input() {
  b_input_ = false;
  clear_has_b_input();
}
inline bool CaffeGenDef_NetValue::b_input() const {
  return b_input_;
}
inline void CaffeGenDef_NetValue::set_b_input(bool value) {
  set_has_b_input();
  b_input_ = value;
}

// required string var_name = 2;
inline bool CaffeGenDef_NetValue::has_var_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CaffeGenDef_NetValue::set_has_var_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CaffeGenDef_NetValue::clear_has_var_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CaffeGenDef_NetValue::clear_var_name() {
  if (var_name_ != &::google::protobuf::internal::kEmptyString) {
    var_name_->clear();
  }
  clear_has_var_name();
}
inline const ::std::string& CaffeGenDef_NetValue::var_name() const {
  return *var_name_;
}
inline void CaffeGenDef_NetValue::set_var_name(const ::std::string& value) {
  set_has_var_name();
  if (var_name_ == &::google::protobuf::internal::kEmptyString) {
    var_name_ = new ::std::string;
  }
  var_name_->assign(value);
}
inline void CaffeGenDef_NetValue::set_var_name(const char* value) {
  set_has_var_name();
  if (var_name_ == &::google::protobuf::internal::kEmptyString) {
    var_name_ = new ::std::string;
  }
  var_name_->assign(value);
}
inline void CaffeGenDef_NetValue::set_var_name(const char* value, size_t size) {
  set_has_var_name();
  if (var_name_ == &::google::protobuf::internal::kEmptyString) {
    var_name_ = new ::std::string;
  }
  var_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CaffeGenDef_NetValue::mutable_var_name() {
  set_has_var_name();
  if (var_name_ == &::google::protobuf::internal::kEmptyString) {
    var_name_ = new ::std::string;
  }
  return var_name_;
}
inline ::std::string* CaffeGenDef_NetValue::release_var_name() {
  clear_has_var_name();
  if (var_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = var_name_;
    var_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CaffeGenDef_NetValue::set_allocated_var_name(::std::string* var_name) {
  if (var_name_ != &::google::protobuf::internal::kEmptyString) {
    delete var_name_;
  }
  if (var_name) {
    set_has_var_name();
    var_name_ = var_name;
  } else {
    clear_has_var_name();
    var_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string var_name_src = 3;
inline bool CaffeGenDef_NetValue::has_var_name_src() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CaffeGenDef_NetValue::set_has_var_name_src() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CaffeGenDef_NetValue::clear_has_var_name_src() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CaffeGenDef_NetValue::clear_var_name_src() {
  if (var_name_src_ != &::google::protobuf::internal::kEmptyString) {
    var_name_src_->clear();
  }
  clear_has_var_name_src();
}
inline const ::std::string& CaffeGenDef_NetValue::var_name_src() const {
  return *var_name_src_;
}
inline void CaffeGenDef_NetValue::set_var_name_src(const ::std::string& value) {
  set_has_var_name_src();
  if (var_name_src_ == &::google::protobuf::internal::kEmptyString) {
    var_name_src_ = new ::std::string;
  }
  var_name_src_->assign(value);
}
inline void CaffeGenDef_NetValue::set_var_name_src(const char* value) {
  set_has_var_name_src();
  if (var_name_src_ == &::google::protobuf::internal::kEmptyString) {
    var_name_src_ = new ::std::string;
  }
  var_name_src_->assign(value);
}
inline void CaffeGenDef_NetValue::set_var_name_src(const char* value, size_t size) {
  set_has_var_name_src();
  if (var_name_src_ == &::google::protobuf::internal::kEmptyString) {
    var_name_src_ = new ::std::string;
  }
  var_name_src_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CaffeGenDef_NetValue::mutable_var_name_src() {
  set_has_var_name_src();
  if (var_name_src_ == &::google::protobuf::internal::kEmptyString) {
    var_name_src_ = new ::std::string;
  }
  return var_name_src_;
}
inline ::std::string* CaffeGenDef_NetValue::release_var_name_src() {
  clear_has_var_name_src();
  if (var_name_src_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = var_name_src_;
    var_name_src_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CaffeGenDef_NetValue::set_allocated_var_name_src(::std::string* var_name_src) {
  if (var_name_src_ != &::google::protobuf::internal::kEmptyString) {
    delete var_name_src_;
  }
  if (var_name_src) {
    set_has_var_name_src();
    var_name_src_ = var_name_src;
  } else {
    clear_has_var_name_src();
    var_name_src_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .CaffeGenDef.VarExtractType vet = 4;
inline bool CaffeGenDef_NetValue::has_vet() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CaffeGenDef_NetValue::set_has_vet() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CaffeGenDef_NetValue::clear_has_vet() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CaffeGenDef_NetValue::clear_vet() {
  vet_ = 1;
  clear_has_vet();
}
inline ::CaffeGenDef_VarExtractType CaffeGenDef_NetValue::vet() const {
  return static_cast< ::CaffeGenDef_VarExtractType >(vet_);
}
inline void CaffeGenDef_NetValue::set_vet(::CaffeGenDef_VarExtractType value) {
  assert(::CaffeGenDef_VarExtractType_IsValid(value));
  set_has_vet();
  vet_ = value;
}

// required string vec_table_name = 5;
inline bool CaffeGenDef_NetValue::has_vec_table_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CaffeGenDef_NetValue::set_has_vec_table_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CaffeGenDef_NetValue::clear_has_vec_table_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CaffeGenDef_NetValue::clear_vec_table_name() {
  if (vec_table_name_ != &::google::protobuf::internal::kEmptyString) {
    vec_table_name_->clear();
  }
  clear_has_vec_table_name();
}
inline const ::std::string& CaffeGenDef_NetValue::vec_table_name() const {
  return *vec_table_name_;
}
inline void CaffeGenDef_NetValue::set_vec_table_name(const ::std::string& value) {
  set_has_vec_table_name();
  if (vec_table_name_ == &::google::protobuf::internal::kEmptyString) {
    vec_table_name_ = new ::std::string;
  }
  vec_table_name_->assign(value);
}
inline void CaffeGenDef_NetValue::set_vec_table_name(const char* value) {
  set_has_vec_table_name();
  if (vec_table_name_ == &::google::protobuf::internal::kEmptyString) {
    vec_table_name_ = new ::std::string;
  }
  vec_table_name_->assign(value);
}
inline void CaffeGenDef_NetValue::set_vec_table_name(const char* value, size_t size) {
  set_has_vec_table_name();
  if (vec_table_name_ == &::google::protobuf::internal::kEmptyString) {
    vec_table_name_ = new ::std::string;
  }
  vec_table_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CaffeGenDef_NetValue::mutable_vec_table_name() {
  set_has_vec_table_name();
  if (vec_table_name_ == &::google::protobuf::internal::kEmptyString) {
    vec_table_name_ = new ::std::string;
  }
  return vec_table_name_;
}
inline ::std::string* CaffeGenDef_NetValue::release_vec_table_name() {
  clear_has_vec_table_name();
  if (vec_table_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vec_table_name_;
    vec_table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CaffeGenDef_NetValue::set_allocated_vec_table_name(::std::string* vec_table_name) {
  if (vec_table_name_ != &::google::protobuf::internal::kEmptyString) {
    delete vec_table_name_;
  }
  if (vec_table_name) {
    set_has_vec_table_name();
    vec_table_name_ = vec_table_name;
  } else {
    clear_has_vec_table_name();
    vec_table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 var_src_idx = 6;
inline bool CaffeGenDef_NetValue::has_var_src_idx() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CaffeGenDef_NetValue::set_has_var_src_idx() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CaffeGenDef_NetValue::clear_has_var_src_idx() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CaffeGenDef_NetValue::clear_var_src_idx() {
  var_src_idx_ = 0;
  clear_has_var_src_idx();
}
inline ::google::protobuf::int32 CaffeGenDef_NetValue::var_src_idx() const {
  return var_src_idx_;
}
inline void CaffeGenDef_NetValue::set_var_src_idx(::google::protobuf::int32 value) {
  set_has_var_src_idx();
  var_src_idx_ = value;
}

// optional int32 vec_table_idx = 7;
inline bool CaffeGenDef_NetValue::has_vec_table_idx() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CaffeGenDef_NetValue::set_has_vec_table_idx() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CaffeGenDef_NetValue::clear_has_vec_table_idx() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CaffeGenDef_NetValue::clear_vec_table_idx() {
  vec_table_idx_ = 0;
  clear_has_vec_table_idx();
}
inline ::google::protobuf::int32 CaffeGenDef_NetValue::vec_table_idx() const {
  return vec_table_idx_;
}
inline void CaffeGenDef_NetValue::set_vec_table_idx(::google::protobuf::int32 value) {
  set_has_vec_table_idx();
  vec_table_idx_ = value;
}

// optional bool b_can_replace = 8;
inline bool CaffeGenDef_NetValue::has_b_can_replace() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CaffeGenDef_NetValue::set_has_b_can_replace() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CaffeGenDef_NetValue::clear_has_b_can_replace() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CaffeGenDef_NetValue::clear_b_can_replace() {
  b_can_replace_ = false;
  clear_has_b_can_replace();
}
inline bool CaffeGenDef_NetValue::b_can_replace() const {
  return b_can_replace_;
}
inline void CaffeGenDef_NetValue::set_b_can_replace(bool value) {
  set_has_b_can_replace();
  b_can_replace_ = value;
}

// optional int32 max_instances = 9;
inline bool CaffeGenDef_NetValue::has_max_instances() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CaffeGenDef_NetValue::set_has_max_instances() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CaffeGenDef_NetValue::clear_has_max_instances() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CaffeGenDef_NetValue::clear_max_instances() {
  max_instances_ = 0;
  clear_has_max_instances();
}
inline ::google::protobuf::int32 CaffeGenDef_NetValue::max_instances() const {
  return max_instances_;
}
inline void CaffeGenDef_NetValue::set_max_instances(::google::protobuf::int32 value) {
  set_has_max_instances();
  max_instances_ = value;
}

// optional float replace_prob = 10;
inline bool CaffeGenDef_NetValue::has_replace_prob() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CaffeGenDef_NetValue::set_has_replace_prob() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CaffeGenDef_NetValue::clear_has_replace_prob() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CaffeGenDef_NetValue::clear_replace_prob() {
  replace_prob_ = 0;
  clear_has_replace_prob();
}
inline float CaffeGenDef_NetValue::replace_prob() const {
  return replace_prob_;
}
inline void CaffeGenDef_NetValue::set_replace_prob(float value) {
  set_has_replace_prob();
  replace_prob_ = value;
}

// -------------------------------------------------------------------

// CaffeGenDef

// required string name = 1;
inline bool CaffeGenDef::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CaffeGenDef::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CaffeGenDef::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CaffeGenDef::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CaffeGenDef::name() const {
  return *name_;
}
inline void CaffeGenDef::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CaffeGenDef::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CaffeGenDef::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CaffeGenDef::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CaffeGenDef::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CaffeGenDef::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 NumSentenceRecsToSearch = 2;
inline bool CaffeGenDef::has_numsentencerecstosearch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CaffeGenDef::set_has_numsentencerecstosearch() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CaffeGenDef::clear_has_numsentencerecstosearch() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CaffeGenDef::clear_numsentencerecstosearch() {
  numsentencerecstosearch_ = 0;
  clear_has_numsentencerecstosearch();
}
inline ::google::protobuf::int32 CaffeGenDef::numsentencerecstosearch() const {
  return numsentencerecstosearch_;
}
inline void CaffeGenDef::set_numsentencerecstosearch(::google::protobuf::int32 value) {
  set_has_numsentencerecstosearch();
  numsentencerecstosearch_ = value;
}

// repeated .CaffeGenDef.DataAccess access_fields = 3;
inline int CaffeGenDef::access_fields_size() const {
  return access_fields_.size();
}
inline void CaffeGenDef::clear_access_fields() {
  access_fields_.Clear();
}
inline const ::CaffeGenDef_DataAccess& CaffeGenDef::access_fields(int index) const {
  return access_fields_.Get(index);
}
inline ::CaffeGenDef_DataAccess* CaffeGenDef::mutable_access_fields(int index) {
  return access_fields_.Mutable(index);
}
inline ::CaffeGenDef_DataAccess* CaffeGenDef::add_access_fields() {
  return access_fields_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CaffeGenDef_DataAccess >&
CaffeGenDef::access_fields() const {
  return access_fields_;
}
inline ::google::protobuf::RepeatedPtrField< ::CaffeGenDef_DataAccess >*
CaffeGenDef::mutable_access_fields() {
  return &access_fields_;
}

// repeated .CaffeGenDef.DataFilter data_filters = 4;
inline int CaffeGenDef::data_filters_size() const {
  return data_filters_.size();
}
inline void CaffeGenDef::clear_data_filters() {
  data_filters_.Clear();
}
inline const ::CaffeGenDef_DataFilter& CaffeGenDef::data_filters(int index) const {
  return data_filters_.Get(index);
}
inline ::CaffeGenDef_DataFilter* CaffeGenDef::mutable_data_filters(int index) {
  return data_filters_.Mutable(index);
}
inline ::CaffeGenDef_DataFilter* CaffeGenDef::add_data_filters() {
  return data_filters_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CaffeGenDef_DataFilter >&
CaffeGenDef::data_filters() const {
  return data_filters_;
}
inline ::google::protobuf::RepeatedPtrField< ::CaffeGenDef_DataFilter >*
CaffeGenDef::mutable_data_filters() {
  return &data_filters_;
}

// repeated .CaffeGenDef.DataTranslate data_translates = 5;
inline int CaffeGenDef::data_translates_size() const {
  return data_translates_.size();
}
inline void CaffeGenDef::clear_data_translates() {
  data_translates_.Clear();
}
inline const ::CaffeGenDef_DataTranslate& CaffeGenDef::data_translates(int index) const {
  return data_translates_.Get(index);
}
inline ::CaffeGenDef_DataTranslate* CaffeGenDef::mutable_data_translates(int index) {
  return data_translates_.Mutable(index);
}
inline ::CaffeGenDef_DataTranslate* CaffeGenDef::add_data_translates() {
  return data_translates_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CaffeGenDef_DataTranslate >&
CaffeGenDef::data_translates() const {
  return data_translates_;
}
inline ::google::protobuf::RepeatedPtrField< ::CaffeGenDef_DataTranslate >*
CaffeGenDef::mutable_data_translates() {
  return &data_translates_;
}

// repeated .CaffeGenDef.NetValue net_values = 6;
inline int CaffeGenDef::net_values_size() const {
  return net_values_.size();
}
inline void CaffeGenDef::clear_net_values() {
  net_values_.Clear();
}
inline const ::CaffeGenDef_NetValue& CaffeGenDef::net_values(int index) const {
  return net_values_.Get(index);
}
inline ::CaffeGenDef_NetValue* CaffeGenDef::mutable_net_values(int index) {
  return net_values_.Mutable(index);
}
inline ::CaffeGenDef_NetValue* CaffeGenDef::add_net_values() {
  return net_values_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CaffeGenDef_NetValue >&
CaffeGenDef::net_values() const {
  return net_values_;
}
inline ::google::protobuf::RepeatedPtrField< ::CaffeGenDef_NetValue >*
CaffeGenDef::mutable_net_values() {
  return &net_values_;
}

// required string files_core_dir = 8;
inline bool CaffeGenDef::has_files_core_dir() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CaffeGenDef::set_has_files_core_dir() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CaffeGenDef::clear_has_files_core_dir() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CaffeGenDef::clear_files_core_dir() {
  if (files_core_dir_ != &::google::protobuf::internal::kEmptyString) {
    files_core_dir_->clear();
  }
  clear_has_files_core_dir();
}
inline const ::std::string& CaffeGenDef::files_core_dir() const {
  return *files_core_dir_;
}
inline void CaffeGenDef::set_files_core_dir(const ::std::string& value) {
  set_has_files_core_dir();
  if (files_core_dir_ == &::google::protobuf::internal::kEmptyString) {
    files_core_dir_ = new ::std::string;
  }
  files_core_dir_->assign(value);
}
inline void CaffeGenDef::set_files_core_dir(const char* value) {
  set_has_files_core_dir();
  if (files_core_dir_ == &::google::protobuf::internal::kEmptyString) {
    files_core_dir_ = new ::std::string;
  }
  files_core_dir_->assign(value);
}
inline void CaffeGenDef::set_files_core_dir(const char* value, size_t size) {
  set_has_files_core_dir();
  if (files_core_dir_ == &::google::protobuf::internal::kEmptyString) {
    files_core_dir_ = new ::std::string;
  }
  files_core_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CaffeGenDef::mutable_files_core_dir() {
  set_has_files_core_dir();
  if (files_core_dir_ == &::google::protobuf::internal::kEmptyString) {
    files_core_dir_ = new ::std::string;
  }
  return files_core_dir_;
}
inline ::std::string* CaffeGenDef::release_files_core_dir() {
  clear_has_files_core_dir();
  if (files_core_dir_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = files_core_dir_;
    files_core_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CaffeGenDef::set_allocated_files_core_dir(::std::string* files_core_dir) {
  if (files_core_dir_ != &::google::protobuf::internal::kEmptyString) {
    delete files_core_dir_;
  }
  if (files_core_dir) {
    set_has_files_core_dir();
    files_core_dir_ = files_core_dir;
  } else {
    clear_has_files_core_dir();
    files_core_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string test_list_file_name = 9;
inline bool CaffeGenDef::has_test_list_file_name() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CaffeGenDef::set_has_test_list_file_name() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CaffeGenDef::clear_has_test_list_file_name() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CaffeGenDef::clear_test_list_file_name() {
  if (test_list_file_name_ != &::google::protobuf::internal::kEmptyString) {
    test_list_file_name_->clear();
  }
  clear_has_test_list_file_name();
}
inline const ::std::string& CaffeGenDef::test_list_file_name() const {
  return *test_list_file_name_;
}
inline void CaffeGenDef::set_test_list_file_name(const ::std::string& value) {
  set_has_test_list_file_name();
  if (test_list_file_name_ == &::google::protobuf::internal::kEmptyString) {
    test_list_file_name_ = new ::std::string;
  }
  test_list_file_name_->assign(value);
}
inline void CaffeGenDef::set_test_list_file_name(const char* value) {
  set_has_test_list_file_name();
  if (test_list_file_name_ == &::google::protobuf::internal::kEmptyString) {
    test_list_file_name_ = new ::std::string;
  }
  test_list_file_name_->assign(value);
}
inline void CaffeGenDef::set_test_list_file_name(const char* value, size_t size) {
  set_has_test_list_file_name();
  if (test_list_file_name_ == &::google::protobuf::internal::kEmptyString) {
    test_list_file_name_ = new ::std::string;
  }
  test_list_file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CaffeGenDef::mutable_test_list_file_name() {
  set_has_test_list_file_name();
  if (test_list_file_name_ == &::google::protobuf::internal::kEmptyString) {
    test_list_file_name_ = new ::std::string;
  }
  return test_list_file_name_;
}
inline ::std::string* CaffeGenDef::release_test_list_file_name() {
  clear_has_test_list_file_name();
  if (test_list_file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = test_list_file_name_;
    test_list_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CaffeGenDef::set_allocated_test_list_file_name(::std::string* test_list_file_name) {
  if (test_list_file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete test_list_file_name_;
  }
  if (test_list_file_name) {
    set_has_test_list_file_name();
    test_list_file_name_ = test_list_file_name;
  } else {
    clear_has_test_list_file_name();
    test_list_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string train_list_file_name = 10;
inline bool CaffeGenDef::has_train_list_file_name() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CaffeGenDef::set_has_train_list_file_name() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CaffeGenDef::clear_has_train_list_file_name() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CaffeGenDef::clear_train_list_file_name() {
  if (train_list_file_name_ != &::google::protobuf::internal::kEmptyString) {
    train_list_file_name_->clear();
  }
  clear_has_train_list_file_name();
}
inline const ::std::string& CaffeGenDef::train_list_file_name() const {
  return *train_list_file_name_;
}
inline void CaffeGenDef::set_train_list_file_name(const ::std::string& value) {
  set_has_train_list_file_name();
  if (train_list_file_name_ == &::google::protobuf::internal::kEmptyString) {
    train_list_file_name_ = new ::std::string;
  }
  train_list_file_name_->assign(value);
}
inline void CaffeGenDef::set_train_list_file_name(const char* value) {
  set_has_train_list_file_name();
  if (train_list_file_name_ == &::google::protobuf::internal::kEmptyString) {
    train_list_file_name_ = new ::std::string;
  }
  train_list_file_name_->assign(value);
}
inline void CaffeGenDef::set_train_list_file_name(const char* value, size_t size) {
  set_has_train_list_file_name();
  if (train_list_file_name_ == &::google::protobuf::internal::kEmptyString) {
    train_list_file_name_ = new ::std::string;
  }
  train_list_file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CaffeGenDef::mutable_train_list_file_name() {
  set_has_train_list_file_name();
  if (train_list_file_name_ == &::google::protobuf::internal::kEmptyString) {
    train_list_file_name_ = new ::std::string;
  }
  return train_list_file_name_;
}
inline ::std::string* CaffeGenDef::release_train_list_file_name() {
  clear_has_train_list_file_name();
  if (train_list_file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = train_list_file_name_;
    train_list_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CaffeGenDef::set_allocated_train_list_file_name(::std::string* train_list_file_name) {
  if (train_list_file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete train_list_file_name_;
  }
  if (train_list_file_name) {
    set_has_train_list_file_name();
    train_list_file_name_ = train_list_file_name;
  } else {
    clear_has_train_list_file_name();
    train_list_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .CaffeGenDef.NetEndType net_end_type = 11;
inline bool CaffeGenDef::has_net_end_type() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CaffeGenDef::set_has_net_end_type() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CaffeGenDef::clear_has_net_end_type() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CaffeGenDef::clear_net_end_type() {
  net_end_type_ = 1;
  clear_has_net_end_type();
}
inline ::CaffeGenDef_NetEndType CaffeGenDef::net_end_type() const {
  return static_cast< ::CaffeGenDef_NetEndType >(net_end_type_);
}
inline void CaffeGenDef::set_net_end_type(::CaffeGenDef_NetEndType value) {
  assert(::CaffeGenDef_NetEndType_IsValid(value));
  set_has_net_end_type();
  net_end_type_ = value;
}

// required string proto_file_name = 12;
inline bool CaffeGenDef::has_proto_file_name() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CaffeGenDef::set_has_proto_file_name() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CaffeGenDef::clear_has_proto_file_name() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CaffeGenDef::clear_proto_file_name() {
  if (proto_file_name_ != &::google::protobuf::internal::kEmptyString) {
    proto_file_name_->clear();
  }
  clear_has_proto_file_name();
}
inline const ::std::string& CaffeGenDef::proto_file_name() const {
  return *proto_file_name_;
}
inline void CaffeGenDef::set_proto_file_name(const ::std::string& value) {
  set_has_proto_file_name();
  if (proto_file_name_ == &::google::protobuf::internal::kEmptyString) {
    proto_file_name_ = new ::std::string;
  }
  proto_file_name_->assign(value);
}
inline void CaffeGenDef::set_proto_file_name(const char* value) {
  set_has_proto_file_name();
  if (proto_file_name_ == &::google::protobuf::internal::kEmptyString) {
    proto_file_name_ = new ::std::string;
  }
  proto_file_name_->assign(value);
}
inline void CaffeGenDef::set_proto_file_name(const char* value, size_t size) {
  set_has_proto_file_name();
  if (proto_file_name_ == &::google::protobuf::internal::kEmptyString) {
    proto_file_name_ = new ::std::string;
  }
  proto_file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CaffeGenDef::mutable_proto_file_name() {
  set_has_proto_file_name();
  if (proto_file_name_ == &::google::protobuf::internal::kEmptyString) {
    proto_file_name_ = new ::std::string;
  }
  return proto_file_name_;
}
inline ::std::string* CaffeGenDef::release_proto_file_name() {
  clear_has_proto_file_name();
  if (proto_file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = proto_file_name_;
    proto_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CaffeGenDef::set_allocated_proto_file_name(::std::string* proto_file_name) {
  if (proto_file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete proto_file_name_;
  }
  if (proto_file_name) {
    set_has_proto_file_name();
    proto_file_name_ = proto_file_name;
  } else {
    clear_has_proto_file_name();
    proto_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string model_file_name = 13;
inline bool CaffeGenDef::has_model_file_name() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CaffeGenDef::set_has_model_file_name() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CaffeGenDef::clear_has_model_file_name() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CaffeGenDef::clear_model_file_name() {
  if (model_file_name_ != &::google::protobuf::internal::kEmptyString) {
    model_file_name_->clear();
  }
  clear_has_model_file_name();
}
inline const ::std::string& CaffeGenDef::model_file_name() const {
  return *model_file_name_;
}
inline void CaffeGenDef::set_model_file_name(const ::std::string& value) {
  set_has_model_file_name();
  if (model_file_name_ == &::google::protobuf::internal::kEmptyString) {
    model_file_name_ = new ::std::string;
  }
  model_file_name_->assign(value);
}
inline void CaffeGenDef::set_model_file_name(const char* value) {
  set_has_model_file_name();
  if (model_file_name_ == &::google::protobuf::internal::kEmptyString) {
    model_file_name_ = new ::std::string;
  }
  model_file_name_->assign(value);
}
inline void CaffeGenDef::set_model_file_name(const char* value, size_t size) {
  set_has_model_file_name();
  if (model_file_name_ == &::google::protobuf::internal::kEmptyString) {
    model_file_name_ = new ::std::string;
  }
  model_file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CaffeGenDef::mutable_model_file_name() {
  set_has_model_file_name();
  if (model_file_name_ == &::google::protobuf::internal::kEmptyString) {
    model_file_name_ = new ::std::string;
  }
  return model_file_name_;
}
inline ::std::string* CaffeGenDef::release_model_file_name() {
  clear_has_model_file_name();
  if (model_file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = model_file_name_;
    model_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CaffeGenDef::set_allocated_model_file_name(::std::string* model_file_name) {
  if (model_file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete model_file_name_;
  }
  if (model_file_name) {
    set_has_model_file_name();
    model_file_name_ = model_file_name;
  } else {
    clear_has_model_file_name();
    model_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string config_file_name = 14;
inline bool CaffeGenDef::has_config_file_name() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CaffeGenDef::set_has_config_file_name() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CaffeGenDef::clear_has_config_file_name() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CaffeGenDef::clear_config_file_name() {
  if (config_file_name_ != &::google::protobuf::internal::kEmptyString) {
    config_file_name_->clear();
  }
  clear_has_config_file_name();
}
inline const ::std::string& CaffeGenDef::config_file_name() const {
  return *config_file_name_;
}
inline void CaffeGenDef::set_config_file_name(const ::std::string& value) {
  set_has_config_file_name();
  if (config_file_name_ == &::google::protobuf::internal::kEmptyString) {
    config_file_name_ = new ::std::string;
  }
  config_file_name_->assign(value);
}
inline void CaffeGenDef::set_config_file_name(const char* value) {
  set_has_config_file_name();
  if (config_file_name_ == &::google::protobuf::internal::kEmptyString) {
    config_file_name_ = new ::std::string;
  }
  config_file_name_->assign(value);
}
inline void CaffeGenDef::set_config_file_name(const char* value, size_t size) {
  set_has_config_file_name();
  if (config_file_name_ == &::google::protobuf::internal::kEmptyString) {
    config_file_name_ = new ::std::string;
  }
  config_file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CaffeGenDef::mutable_config_file_name() {
  set_has_config_file_name();
  if (config_file_name_ == &::google::protobuf::internal::kEmptyString) {
    config_file_name_ = new ::std::string;
  }
  return config_file_name_;
}
inline ::std::string* CaffeGenDef::release_config_file_name() {
  clear_has_config_file_name();
  if (config_file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = config_file_name_;
    config_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CaffeGenDef::set_allocated_config_file_name(::std::string* config_file_name) {
  if (config_file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete config_file_name_;
  }
  if (config_file_name) {
    set_has_config_file_name();
    config_file_name_ = config_file_name;
  } else {
    clear_has_config_file_name();
    config_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 num_accuracy_candidates = 15;
inline bool CaffeGenDef::has_num_accuracy_candidates() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CaffeGenDef::set_has_num_accuracy_candidates() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CaffeGenDef::clear_has_num_accuracy_candidates() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CaffeGenDef::clear_num_accuracy_candidates() {
  num_accuracy_candidates_ = 0;
  clear_has_num_accuracy_candidates();
}
inline ::google::protobuf::int32 CaffeGenDef::num_accuracy_candidates() const {
  return num_accuracy_candidates_;
}
inline void CaffeGenDef::set_num_accuracy_candidates(::google::protobuf::int32 value) {
  set_has_num_accuracy_candidates();
  num_accuracy_candidates_ = value;
}

// required string netgen_output_file_name = 18;
inline bool CaffeGenDef::has_netgen_output_file_name() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CaffeGenDef::set_has_netgen_output_file_name() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CaffeGenDef::clear_has_netgen_output_file_name() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CaffeGenDef::clear_netgen_output_file_name() {
  if (netgen_output_file_name_ != &::google::protobuf::internal::kEmptyString) {
    netgen_output_file_name_->clear();
  }
  clear_has_netgen_output_file_name();
}
inline const ::std::string& CaffeGenDef::netgen_output_file_name() const {
  return *netgen_output_file_name_;
}
inline void CaffeGenDef::set_netgen_output_file_name(const ::std::string& value) {
  set_has_netgen_output_file_name();
  if (netgen_output_file_name_ == &::google::protobuf::internal::kEmptyString) {
    netgen_output_file_name_ = new ::std::string;
  }
  netgen_output_file_name_->assign(value);
}
inline void CaffeGenDef::set_netgen_output_file_name(const char* value) {
  set_has_netgen_output_file_name();
  if (netgen_output_file_name_ == &::google::protobuf::internal::kEmptyString) {
    netgen_output_file_name_ = new ::std::string;
  }
  netgen_output_file_name_->assign(value);
}
inline void CaffeGenDef::set_netgen_output_file_name(const char* value, size_t size) {
  set_has_netgen_output_file_name();
  if (netgen_output_file_name_ == &::google::protobuf::internal::kEmptyString) {
    netgen_output_file_name_ = new ::std::string;
  }
  netgen_output_file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CaffeGenDef::mutable_netgen_output_file_name() {
  set_has_netgen_output_file_name();
  if (netgen_output_file_name_ == &::google::protobuf::internal::kEmptyString) {
    netgen_output_file_name_ = new ::std::string;
  }
  return netgen_output_file_name_;
}
inline ::std::string* CaffeGenDef::release_netgen_output_file_name() {
  clear_has_netgen_output_file_name();
  if (netgen_output_file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = netgen_output_file_name_;
    netgen_output_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CaffeGenDef::set_allocated_netgen_output_file_name(::std::string* netgen_output_file_name) {
  if (netgen_output_file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete netgen_output_file_name_;
  }
  if (netgen_output_file_name) {
    set_has_netgen_output_file_name();
    netgen_output_file_name_ = netgen_output_file_name;
  } else {
    clear_has_netgen_output_file_name();
    netgen_output_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CaffeGenDef_AccessType>() {
  return ::CaffeGenDef_AccessType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CaffeGenDef_MatchType>() {
  return ::CaffeGenDef_MatchType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CaffeGenDef_FilterMatchType>() {
  return ::CaffeGenDef_FilterMatchType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CaffeGenDef_WordDataType>() {
  return ::CaffeGenDef_WordDataType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CaffeGenDef_DataTranslateType>() {
  return ::CaffeGenDef_DataTranslateType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CaffeGenDef_VarExtractType>() {
  return ::CaffeGenDef_VarExtractType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CaffeGenDef_NetEndType>() {
  return ::CaffeGenDef_NetEndType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_GenDef_2eproto__INCLUDED
